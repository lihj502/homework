# 	python学习笔记

   * [python学习笔记](#python学习笔记)
      * [一、学习python前的准备工作](#一学习python前的准备工作)
      * [二、学习python前的一些基础知识](#二学习python前的一些基础知识)
      * [三、变量（variable）](#三变量variable)
         * [3.1 变量储存的一个详细的解释：](#31-变量储存的一个详细的解释)
         * [3.2 变量的值](#32-变量的值)
      * [四、python的print()内置函数](#四python的print内置函数)
         * [4.1 print()函数简介](#41-print函数简介)
         * [4.2 输出内容的格式化](#42-输出内容的格式化)
         * [4.3 多行输出](#43-多行输出)
      * [五、用于用户输入的内置函数input（）](#五用于用户输入的内置函数input)
         * [5.1 input()函数中的用户输入及返回值](#51-input函数中的用户输入及返回值)
      * [六、字符串](#六字符串)
         * [6.1 字符串的索引](#61-字符串的索引)
         * [6.2 格式化的字符串输出](#62-格式化的字符串输出)
      * [七、初识函数和方法的区别](#七初识函数和方法的区别)
      * [八、算术运算](#八算术运算)
         * [8.1 算术运算符](#81-算术运算符)
         * [8.2 算术运算函数及方法](#82-算术运算函数及方法)
      * [九、if语句](#九if语句)
         * [9.1 if语句初识](#91-if语句初识)
         * [9.2 与if语句判断相关运算符](#92-与if语句判断相关运算符)
      * [十、pycharm功能介绍——变量名重构](#十pycharm功能介绍变量名重构)
      * [十一、while循环](#十一while循环)
      * [十二、for循环](#十二for循环)
      * [十三、列表（list）](#十三列表list)
         * [13.1 列表初识](#131-列表初识)
         * [13.2 列表方法（列表函数）](#132-列表方法列表函数)
      * [十四、元组（tuples）](#十四元组tuples)
         * [14.1 元组初识](#141-元组初识)
         * [14.2 元组之解压缩（unpacking）](#142-元组之解压缩unpacking)
      * [十五、字典（dictionaries）](#十五字典dictionaries)
      * [十六、函数（function）](#十六函数function)
         * [16.1 函数初识](#161-函数初识)
         * [16.2 向自定义函数中传递参数](#162-向自定义函数中传递参数)
         * [16.3 使用return语句使函数出现返回值](#163-使用return语句使函数出现返回值)
      * [十七、处理错误的语句try、<code>except</code>](#十七处理错误的语句tryexcept)
      * [十八、注释（comments）](#十八注释comments)
      * [十九、类（class）](#十九类class)
         * [19.1 类初识](#191-类初识)
         * [19.2 创建对象](#192-创建对象)
         * [19.3 类中的继承（inheritance）](#193-类中的继承inheritance)
      * [二十、模块（modules）](#二十模块modules)
         * [20.1 模块的使用方法一](#201-模块的使用方法一)
         * [20.2 模块的使用方法二](#202-模块的使用方法二)
      * [二十一、包（package）](#二十一包package)
         * [21.1 包初识](#211-包初识)
         * [21.2 错误插曲之路径问题](#212-错误插曲之路径问题)
         * [21.3 包的使用实例](#213-包的使用实例)
      * [二十二、python的内置模块](#二十二python的内置模块)
         * [22.1 文件操作的辅助模块](#221-文件操作的辅助模块)
      * [二十三、文件操作](#二十三文件操作)
         * [23.1 编码格式](#231-编码格式)
         * [23.2 文件读写](#232-文件读写)
         * [23.3 文件操作的其他方法](#233-文件操作的其他方法)
         * [23.3 上下文管理器（with语句）](#233-上下文管理器with语句)
         * [23.4 OS模块（python内置模块）](#234-os模块python内置模块)

例如python的简介，历史，性质这些等以后大多数的知识都学完了之后再去学习。

了解一下什么是环境变量

别忘了最后进行重新检查以及查漏补缺，和文档的排版工作，还有就是各种模块的命名和整理，现在各种知识点所处的模块有点乱，但是不建议你现在就进行整理，先全学完才是最重要的

要在第二次的整理时使用一些比如下划线，加粗，高亮的语法

建议你在第二次整理的时候可以参照廖雪峰的网站中的文档来整理，顺便查漏补缺

整体排版的时候有以下的几点需要去注意：

1. 图片的大小统一用img的width来控制，不用zoom
2. 引用符号全部弃用
3. 每个章节进行格式的排版，写成正规目录的格式
4. 复制到GitHub的本地仓库中再使用命令进行提交

## 一、学习python前的准备工作

- **编码器:**  python3.x

- **解释器:**  将python的语言进行翻译或者解释为计算机可以识别的二进制语言的程序。

  由于所学习的教程所使用的软件是pycharm，因此我的解释器同样使用pycharm（但是还有很多的解释器可以使用，比如vscode，不过需要安装一些拓展插件）。

  这个pycharm在使用的过程中发现写的代码似乎是不需要进行保存的，都是自动进行保存的。



## 二、学习python前的一些基础知识

**PS:**因为Python是解释型语言，因此python的代码是一行一行执行的。

这就给python了一个和c语言不同的特点，如果代码中有语法错误，python也不会直接报错完全不执行，由于它是从上向下一行行的执行代码，因此上面的代码依然会被正常的执行，直到遇到有错误的代码以后才会停止执行（即不再对后面的代码进行运行，停在了出错的代码行），并在运行的窗口出现当前代码的报错信息，这样就可以更加清晰的发现自己错误的精确位置，并有利于改正。

此图中程序运行到第二行即停止，不过其实在coding的时候，如果**出现一些拼写和语法错误，你的代码下面就会出现红色波浪线，以及一个红色的灯泡**，注意这个可以有效的减少拼写错误。

它会指出你错误的语句所处的文件的路径，以及文件名，还有这条语句在文件内所处的具体位置，甚至最后输出了你的错误语句，之后的下一行是对错误的描述。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113081706.png" width = "700px" />



## 三、变量（variable）

变量几乎存在于所有编程语言中，我们使用它在计算机内存中**用于临时储存数据**。

在python中你，如果将要使得数值存放在一个变量中，**没有类似于c语言中变量使用前的定义工作**，可以直接通过一条赋值语句完成将数值储存在变量中的操作。

### 3.1 变量储存的一个详细的解释：

当解释器执行为变量赋值的语句的时候，首先解释器会为这个变量分配一块内存，然后它会将马上要赋给变量的值储存在片区域，在最后将定义的变量名作为这片区域的标签，之后对于这个区域所储存的值可以直接通过引用这个标签（变量名）来进行调用。

**PS:**  和c语言不同，如果我们写入print（“变量名”），python会将这个变量名看作一个将要输出的字符串，而不是需要被调用值，因此需要将变量直接放置在括号中，不需要添加任何引号。

**下面是一个小示例（注意print括号内的内容）**

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113084110.png" width = "450px" />

### 3.2 变量的值

对变量内部的值同样可以通过位于第一次赋值的语句之后的新赋值语句进行**重置**。

**python对于变量的定义类型没有要求**，一个变量中**可以储存整数、浮点数、字符串、布尔值**（Ture、False需要**开头的字母使用大写**，否则python无法将其识别为布尔值）。

通过如下的尝试可以看出，我们定义的变量没有被定义为一个只能存储固定的类型值的区域，它可以随着存储的值的类型不同而进行更改（或者说python语句中的变量没有固定类型），我们完全可以使用不同类型的值对同一个变量内的值使用赋值语句进行连续的重置（确实比c语言方便）。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113085314.png" width = "300px" />

其中，**变量名区分**大小写（为了避免错误的使用，变量名最好始终使用小写），可以使用字母，下划线（下划线通常使用于当一个有意义的变量是几个单词组成的时候，如果使用空格会无法识别，因此使用下划线代替空格连接两个单词）。



## 四、python的`print()`内置函数

### 4.1 print()函数简介

**print('')或者print("")都符合python的语法规范**，其中这个双引号（单引号）中相当于定义了一个字符串。

**PS:**  python的语句的结尾没有分号。

print的括号里面是是一个表达式，除了分号内的字符串以外，我们同样可以在双引号（单引号）外面，括号内部，添加一些运算符，这样，解释器会对整个括号内进行一个分析，最后输出括号内的最终值。

**PS:**  一旦使用单引号（双引号），那么这里面就不能再使用单引号（双引号）了，可以用不同的引号来代替，比如用了单引号就用双引号。

如果在输出语句中想要不止输出字符串，还想同时调用变量值，那么需要将输出的字符串的边界引号外加上一个“+”来连接字符串以及变量。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113101040.png" width = "350px" />

### 4.2 输出内容的格式化

使用时，如果输出的字符串之后（之前）还要加上一个变量，那么最好在每一个将要输出的字符串的结尾（开头）加上一个空格，这样可以使得输出的字符串不会看起来过于拥挤。

同时需要提示的是，空格要加在引号的里面，这样才会正常的将空格输出，如果加在变量旁边或者运算符旁边，那么它的作用只有一个，就是使得代码可阅读性增强，加入再多的空格也不会对最终的输出有任何的影响。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113102441.png" width = "450px" />

当然我们也可以直接把这段代码中的第二行print的功能直接压缩到第三行的input中。

### 4.3 多行输出

那么如果在输出的时候想要一次性的输出多行文字形成一个类似文章的样式，那么就无法通过单纯的使用一对单引号（双引号）来完成操作，否则就是写再多的行，最终在输出的时候依然会合并到一行。

此时就需要使用**三对单引号（双引号）**来完成，可以在赋值语句中使用三对引号来定义一篇多段的字符串文章，也可以**在print函数中使用三对引号直接输出一篇多段的字符串文章**。

**PS:** 在自己尝试的时候发现pycharm还可以自动检查英文单词是否有拼写的错误，如果有，会用绿色波浪线画出

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113150749.png" width = "450px" />



## 五、用于用户输入的内置函数`input（）`

### 5.1 input()函数中的用户输入及返回值

事实上无论是input还是print都是python中所构建的函数，因此被称作内置函数。我们使用这些的过程函数就是我们在调用或者执行这个函数。

在input（）函数中，首先可以添加引号，来先进行终端输出，之后再等待接收用户输入值，之后会将用户输入的值返回，这时我们通常使用一个变量将这个返回值储存在内存中。

**PS:  但是要注意的是，这个返回值无论用户输入的是什么，都会默认返回字符串类型。**

因此进行程序编写的过程中出现了如下问题：

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113115622.png" width = "600px" />

**错误原因:**  整型数值无法和字符串做运算

为了解决这个问题，此时引入了**几个可以将值的类型转化为指定类型的函数。**

- int() ——转化为整数。
- float() ——转化为浮点数。
- bool() ——转化为布尔值。
- str() ——转化为字符串。

使用的方法就是将需要转化的变量或者值传入这个函数（即写到括号中），这样这个函数的返回值就变为了这个函数所代表的类型。

因此通过这个转化类型的函数就能够解决这个问题了。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113115942.png" width = "300px" />

可以使用**type()函数**来查看type括号中写入的变量的类型，将会返回一个类似标签的语句，其中标注这个变量值的类属于什么类型。

**对语句尝试进行合并:**  

下面让我们来看看是否能够不单独进行类型的转换，而直接在input函数返回值的同时进行类型的转换再赋给变量：

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113110426.png" width = "600px" />

首先这个语法错误的意思是无效语法。

虽然不知道这句话到底是哪里错了，但是那么将这个错误删除能否正常的运行呢？

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113110923.png" width = "500px" />

这个语法错误的意思是解析时意外遇到了[EOF](https://baike.baidu.com/item/EOF/1017800?fr=aladdin)（End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。资料源通常称为档案或串流。通常在文本的最后存在此字符表示资料结束。）。

仔细检查这个语句以后，发现其实是少了一个括号。。。。。。。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113114754.png" width = "500px" />

看来这样的转换确实可以省去多分出一行写转化语句的步骤。

下面这个错误告诉我，**输出语句中，字符串只可以用加号连接存放字符或字符串的变量，不可以是其他形式变量。**

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113115154.png" width = "500px" />





## 六、字符串

### 6.1 字符串的索引

在python中字符串会被规定索引，类似于c语言中的数组，python字符串的第一个字母的索引也是0

可以使用print函数单独输出索引对应的字母

**类似的语法:**  `print(word[0])`

可以通过正序从0一直向后数，当然也可以逆序，在这里规定python中的字符串的最后一位的索引除了正序数出来的数值以外，同时也是-1，因此**也可以使用这样的逆序来数数值**

如果**要输出一段字符，则使用`print(word[0:12])`**这样的语法，第一个输出的字符为开头的索引对应的字符，最后一个输出的字符为除了最后一个索引对应的字符以外，这一段区间内的所有字符。

对于这样的表示来说，有着它的默认值，**第一个数字的默认值是第一个字符，最后一个数字是最后一个字符的下一个索引**（即输出到最后一个字符，并包括最后一个字符）

但是必须让左边的索引对应的字符和右边索引对应字符在字符串中的**顺序一定是从左到右**，一旦位置相反，就无法输出（但是却不会报错）

**PS:**  不是索引数值的大小，而是索引对应字符在字符串中的相对位置的顺序必须是严格从左到右

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113155100.png" width = "300px" />

如果**索引超出了对应字符的范围**，也不会报错，只不过会在输出最后的（最前的）字符之后停止输出

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113155611.png" width = "300px" />

### 6.2 格式化的字符串输出

对于赋值来说，同样可以通过使用“+”将一个变量和一个字符串连起来赋给另外的一个变量

但是这样的方式当我们需要赋值一个十分复杂的文本的时候，就会很麻烦。

因此引入了格式化的字符串输出，首先使用`f`进行定义，之后使用单引号，在单引号中输入将要输入的句子，在这里面可以使用一个大括号包裹将要输出的变量名其他的照常。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113183034.png" width = "300px" />

这是两种输出方式，同样也可以用于给变量进行字符串的赋值。



## 七、初识函数和方法的区别

函数是通用于各种类型的，而方法是特定用于某种类型的。

1. **`len()`**用来计算变量中值的长度。

**方法的部分示例**

1. **`upper()`方法**是将字符串中的每一个字符都变为大写，**需要在变量的后面加上`·`**再使用有着对应的功能的方法。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113184614.png" width = "500px" />

当然，有着将每个字符转换为大写的函数，当然也对应存在着将每个字符转换为小写的函数**`lower()`**。

2. **`find()`方法**，向这个方法内传入一个将要查找的字符，之后这个方法会返还这个字符所存在的索引的位置。

   当然，也可以向这个方法内传入一段字符串，之后将会返还这段字符串的首字母对应的索引。

   如果所查找的字符串中有很多将要被查找的字符，那么方法会默认返回第一个字符存在的索引。

3. **`replace()`方法**，需要传入两个参数，第一个是将要替换的字符或字符串，第二个是将要代替这个字符或字符串的字符或字符串。

   **PS:**  如果方法中传入的第一个字符或者字符串着有一点不同的，都会导致无法进行替换（但是不会报错），再次输出还是原来的字符。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210113190431.png" width = "500px" />

**总结这里面所包含的内容：**

- `len()`
- `somevariate.upper()`
- `somevariate.lower()`
- `somevariate.find()`
- `somevariate.replace()`
- `'....' in somevariate`



## 八、算术运算

### 8.1 算术运算符

python有着和c语言中一样的算数运算符“+”、“-”、“/”、“%”、“*”、“+=”、“-=”、“ *=”、“/=”

“+=”这样的运算符又被称为增广（强）赋值运算符

这里面除号默认结果是浮点数型，取余运算默认结果是整数型

但是他也有着c语言所不具有的**全新运算符**“//”——除法最终得到的数值是商的整数位，以及“**”——幂运算（前面的数字代表底数，后面的数字代表指数）

由此也可以推广出这两个新的运算符也有相对应的**增广赋值运算符**“//=”、“**=”

python和c语言一样保持着一致的运算符运算优先顺序（操作符优先级），当然也可以使用括号来对运算顺序进行一些改变

**PS:**  当然由于有着新的运算符的存在，增添了一些新的运算顺序，例如幂运算“**”最先

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210114083623.png" width = "300px" />

### 8.2 算术运算函数及方法

**部分算数函数:**  

- `round()`圆函数，对传入括号内的浮点数进行四舍五入并放回得到的结果

- `abs()`绝对值函数，对传入括号的数值进行取绝对值运算并在最终返回对应的正数结果

**python模块，导入的语法类似`import something`**

在python中，**模块是一个具有可重用性的独立文件代码**

**在这里简单的介绍数学模块的部分方法**

- `math.ceil()`四舍五入方法
- `math.floor()`取整数位方法

具体的内容可以去查看在官网下载的python安装包中同时下载的官方文档，即结尾是Docs的文档，可以在那里面找math模块

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210114085415.png" width = "600px" />

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210114085622.png" width = "800px" />

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210114085657.png" width = "600px" />



## 九、if语句

### 9.1 if语句初识

首先，**if语句是由布尔值来进行控制，格式是`if somevaritae:`**

**PS:**  if和后面的变量名之间需要一个空格来分开，同时这个变量中储存布尔值

如果是Ture，那么if语句就会**执行下面缩进的语句**（由此可以看出，虽然python没有像c语言一样的大括号来表示语句结束，但是它同样有着自己的判断方式，也就是“缩进”，而这也提醒着我们使用这个语句的时候要特别注意缩进的问题，严格按照语法进行缩进）

对于没有缩进的语句，它会按照正常的语句进行对待，也就是说，缩进就相当于python的if语句中的大括号。

当然python和c语言的if语句同样存在相似的语法，例如都有else，不过需要注意的是python的**else需要先取消缩进以后再进行再编写**，**语法是`else:`**

相比于c语言中的else if来说，python更加的简洁，使用**`elif`**，当然后面同样需要一个空格加上一个变量名。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210114104909.png" width = "800px" />

### 9.2 与if语句判断相关运算符

**或与非**

- 逻辑运算符——`and`，使用在if语句的变量布尔值判断中，和c语言中的`&&`意义相同

- 逻辑运算符——`or`，同样使用在if语句的变量布尔值判断中，和c语言中的`||`意义相同

- 逻辑运算符——`not`，将后面的布尔值反转

**其他运算符**

- `in`运算符，用来检查字符或者字符串中是否存在某个字符或者某段字符的时候使用。

  **使用方法规范:**  `something in somevariate`，这个表达式会返回一个布尔值，当然如果something中有任意一个拼写错误或者大小写的不同都将会导致返回值是一个False。

- 比较运算符——`>` `<` `==` `<=` `>=` `!=`

  和c语言中的用法相似，只不过在if语句中的使用需要遵循python语句的if语法规则

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210114201409.png" width = "800px" />



## 十、pycharm功能介绍——变量名重构

这里介绍pycharm的重构功能，对于想要修改的变量选定后，鼠标右击出现如下选项，找到rename

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210114213045.png" width = "450px" />

之后会出现选项框，即可输入将要修改的变量名

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210114213310.png" width = "300px" />

这个功能的优点是可以**对于目前`.py`文件的变量名全部进行更改**，减少了变量名一个个修改的麻烦

**由此可以引申出一个我目前能想到的这个功能的应用**

比如在一个大的程序里（可能会有很多行代码），在写的时候，我可以对各种使用的变量名进行简写使用（这样可以加快coding的速度），在程序完成之后，在对于简写的变量名进行重构，使用有意义的单词来代替，这样再重复浏览的时候可以避免对于变量名意义的遗忘和混淆。



## 十一、while循环

最基础的while循环规则和c语言中的相同，**`while 判断语句(返回一个布尔值):`**是最基础的语法，当然，python依然选择使用缩进来确定那些语句位于循环的内部

但是和c语言不同的地方在于，**python中while循环多了一个else语句**（不要和if中的else语句混淆），如果循环在中间被break，那么这个else语句不会进行，但是如果循环语句完全进行到条件不再满足以后才结束，那么就会执行else语句中的内容。

**对于下面的这个程序，我认为重要的是以下几点：**

- 死循环的写法——`Ture`
- `print('''''')`这里面输出的多行文字如果需要没有多余的空行以及多余的缩进，需要删除所有输入中多余的空行和自动生成的缩进

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210115092219.png" width = "500px" />

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210115092331.png" width = "300px" />



## 十二、for循环

相对于多次循环执行一段代码的while循环，在python中，for循环被用于迭代一个集合的项目，它更类似于从c语言中可以进行循环的for循环向更加专能的纯遍历方向进行发展。

**这里先简单的介绍一下什么是列表**

首先我们使用方括号来定义列表，这个方括号中的每一个独立的单位都使用逗号进行分割，这里面存放的每一个独立单位可以是字符、字符串、数字等等，而且经过尝试，一个列表中的各个单元的类型可以不同（但是列表不可以存放布尔值）

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210115161208.png" width = "300px" />

为了解决需要一个大的数字列表的实际应用问题，比如1到100之类的，那如果使用列表一个个的键入似乎看起来不符合代码简洁的原则，因此在这里就会拓展出一个函数

**范围函数：`range()`**

如果向范围函数中仅仅**传入一个参数（整数）**，那么这个范围函数就会生成一个相应长度的一个对象（从零开始），但是并不是一个列表

如果向范围函数中**传入两个参数**，那么首先这两个参数需要使用逗号隔开，第一个参数会被看作生成的一大串数字中的起使数字，而第二个参数将会被看作是终止数字，但是生成的时候并不会包括终止数字

如果**传入三个参数**，那么前两个参数和传入两个参数时的含义相同，而第三个参数则是生成的这一大串数字中相邻数字之间大小之差（可以看作是等差数列中的公差）

**下面介绍if语句的语法格式：`for somevariate in ...:`**

**PS:**  这里somevariate代表着一个不需要提前声明的变量，在每一轮的遍历中，存放in后面的列表（或者字符串中的每个字符，因为一个字符串就可以看作是一个字符序列就类似于一个集合。再或者是一个存放着字符串或者列表的变量）每一轮遍历返回的一个值，当然在下一轮开始之后将会被新的值进行覆盖

**python中的循环和c语言中循环的嵌套规则相似**

**一道练习题——在终端打印出用“x”组成的“F”形状**

首先是使用刚刚学到的嵌套循环（如果使用while循环那么思路和c语言中的差不多，但是如果使用for循环，那么就需要一些函数的帮助），当然这里面存在这一些你之前没有学到 的方法，要**注意我的代码中是如何将x通过循环输入到一行的**

**PS:**  是使用的**字符串的加法**，一个python和c语言完全不同的语法规则！

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210115165718.png" width = "300px"/>

下面这个就是因为使用了for循环，因此引入了range()函数

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210115170337.png" width = "300px" />

那么接下来使用python的简洁语法方式来解决这个问题

这里就需要去适应python中很多简洁方便的语法，有时改变原来c语言的思路去使用python的思路去思考问题会大大减少代码量

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210115165841.png" width = "300px" />



## 十三、列表（list）

### 13.1 列表初识

**列表语法规范：`[..., ..., ..., ...]`**

如果定义一个列表之后，再直接对列表进行输出，那么输出的不只是列表内的内容，同时也会将中括号一同输出到终端。

同时，类似于使用索引访问字符串中的单个字符，列表也可以使用索引去访问每一个单元的元素，不过需要使用保存这个列表的变量

**列表索引使用语法格式：`somevariate[number]`**

不过和使用索引访问字符串中的单个字符不同，如果在中括号中使用了冒号`:`，在各个单位元素的选择上规则一致，但是**列表使用带冒号的索引方式输出到终端上时，会带有中括号**。

**PS:**  这个使用索引的方式返回的相当于一个全新的列表

当然有了这个索引的语法以后，我们可以通过使用索引的方式访问列表之后对访问的元素进行修改（当然这个修改并非真正意义上的修改，而是使用新的值去替换原来位置的元素）

**以上的列表学习还仅仅是对一维层面的学习，下面将会对于二维列表进行学习**

二维列表就类似于对列表进行的嵌套

**二维列表的语法规范：**

```
[
[],
[],
...
]
```

对于二维列表的遍历，对于行和列的遍历顺序和c语言不同需要有一个准确的顺序，**先进行遍历再次进行列遍历**（而这里的列遍历事实上就是对于挑选出的一维列表中的元素进行一次索引）

因为对于二维列表的遍历来说，首先挑选出来的行如果进行输出依然是一个完整的一维列表，没有办法先进行列遍历，同时这样的遍历的操作也没有他的意义

### 13.2 列表方法（列表函数）

- **`列表名.append()`:**  传入的参数是将要添加在列表末尾的元素

- **`列表名.insert()`:**  传入的第一个参数是一个索引（这个索引决定了元素添加在列表的什么位置），第二个参数则是我们实际要添加入列表的元素

  **PS:**  在使用了这个插入方法后，将会占有插入的位置，但是并不会覆盖原有插入的位置，原有的位置及后面的位置将会进行顺移

- **`列表名.remove()`:**  传入的参数只有一个，那就是将要从这个列表中移除的元素（但是并不会改变列表中其他元素的顺序）

- **`列表名.clear()`:**  不需要传入任何的参数，它的作用是清空列表

- **`列表名.pop()`:**  和clear类似不需要传入任何的参数，因为删除的元素的位置已经定在列表的最后一位

- **`列表名.index()`:**  这个方法用来寻找所传入的参数（一个元素），是否存在于列表中，如果存在，那么将会返还这个元素位于列表中的索引数值；那么如果列表中不存在传入的参数，那么系统会报错（报错结果如下）

  <img src="https://gitee.com/gritandsea/picture/raw/master/img/20210118112627.png" width = "300px"/>

  那么根据这个方法的特点**可以拿它来检查列表中是否存在我所查找的参数**，但是在python中还有另外一种我认为**更加优秀的方式来代替它**（因为**使用这个方法会报错，影响程序的连贯性**）

  使用**`in`运算符**，它的**语法格式为`某个元素 in 列表名称`**最终会返还一个布尔值，而这样就不会产生报错问题

- **`列表名.count()`**:  这个方法常用来计算列表中所包含的传入参数的数量，最终返还数量值

- **`列表名.sort()`:**  对列表进行排序，不需要任何的参数传入，结果将是对列表进行升序排列

- **`列表名.reverse()`:**  和上面的sort方法相反，它是对列表进行降序排列

- **`列表名.copy()`:**  这个方法可以对现有的列表进行复制（当然，我需要另一个变量来储存复制后的列表，不然这个方法调用就没有意义了）

**如下是对于方法的一个应用示例（同时这里还有not和in的用法）**

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210118152819.png" width = "300px"/>



## 十四、元组（tuples）

### 14.1 元组初识

**元组性质简介:**  在python中元组和列表相似，也**可以存储一系列的元素**，但是和列表不同的是，在元组中，我们不能添加新元素，不能删除现有元素，不能修改内部的元素，也就是说，**元组是不可变的**

**元组格式:**  我们用中括号代表列表，用**小括号代表元组 `元组 = (各种元素)`**

在元组中能够使用的方法没有列表中的多（因为元组有着不可变的性质，因此方法只能用来获得元组的相关信息），但是我们依然可以使用count来记录元组中我们要查找的参数的数量，以及我们可以使用index去搜素我们要查找的元素的索引

### 14.2 元组之解压缩（unpacking）

下面来举一个例子

如果我设定一个元组`number = (1, 2, 3)`

接着我想要调用元组中的每一个数值进行使用，按照c语言的思路那么会有这样的代码

```python
x = number[0]
y = number[1]
z = number[3]
```

或者直接使用`number[0]`、`number[1]`、`number[2]`来进行运算

但是python中有一个超级简洁的语法被称作解压缩，**`x, y, z = number`**就等于上面的那三个赋值式，将元组内对应位置的元素赋给左边对应位置的变量

**PS:  但是需要去知道的是这个解压缩语法并不是元组的专用，列表同样可以使用这个语法**



## 十五、字典（dictionaries）

**字典简介:**  我们经常会使用字典来储存作为键值对（一种属性对应一种值的关联形式被称为键值对）的信息

**字典定义格式:  `字典名称 = {各种键值对}`**

**PS:**  重要的是一个字典中存在的各种键值对的属性值一定是要唯一的

在字典中，属性可以是字符串（但是不要忘了使用双引号来包括这个属性），也可以是数字。

在字典中，这些属性对应的值可以是很多类型的元素，比如数值、字符串、布尔值、列表等

**访问字典的格式:  `字典名称[指定键名（属性名）] `**

这样就会返回我们存入字典中键名对应的值，但是如果传入的键名并不存在于我们所定义的字典中，那么就会出现一个关键词错误，因为计算机没有在定义的字典中找到我们传入的键名，同时不要忘记在引用键名的时候如果键名是一个字符串的话，则需要使用双引号来包括字符串

对于一旦传入的键名在字典中不存在，则程序报错这个问题（影响程序运行的连续性），有相应的字典方法**`字典名称.get()`**，对于这个方法，同样是传入我们想要的键名，一旦这个传入的键名在字典中不存在，那么程序也不会报错，只是这个方法会返回一个**`None`值**（它是一个代表没有值的一个对象），当然，这个方法还可以传入另外一个参数，那么就是如果字典中找不到我们输入的键名，并不会返还None，而是返还我们输入的第二个值作为不存在的默认值。

当然我们也有对应的语句对字典内部的键值进行更新（不过会出现黄色提示波浪线，不过只要清楚自己在干什么就不用管这个警告）**`字典名称[指定键名] = 将这个键名对应键值要更改为什么值`**

**PS:**  通过这个语法语句，我们同样可以对我们的字典内的键值对进行一个新的增添

下面的这个程序需要学习的是**`message.split()`这个方法**，这个方法可以将传入的参数当作一个识别的信号，只要遇到这个参数，那么调用这个方法的字符串就会被分割一次，之后每一次的分割都会产生一个独立的元素，最终组成一个新的列表

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210118195537.png" width = '300px'/>



## 十六、函数（function）

### 16.1 函数初识

函数的目的是使用一个更好的方式来组织我们的代码，将代码按照功能模块分解成一块块更小更加易于管理的代码。（功能模块化的思想在构建一些大型的复杂程序中十分重要）因此函数是用于执行特定的一些代码的一个容器。其实我们已经接触了一些python中内置函数，例如`print()`、`input()`

**函数定义的格式:  `def 函数名（命名规则和变量命名相同）():`**之后按下回车之后下面的输出就会自动缩进，**只有这一片缩进的代码会被当作能够执行的代码**，**函数的调用格式为`函数名()`**即可

**PS:**  使用函数的时候，为了更好的格式化代码，自定义函数的后面和主函数之间要有两个空行（否则会有黄色的波浪线warning）。并且要注意定义函数要在主函数的上方否则程序会出现报错

### 16.2 向自定义函数中传递参数

这里就和c语言的语法十分的类似（只不过因为c语言变量的定义需要指定类型但，是python的变量定义不需要指定变量的类型），**在所定义的函数括号中添加一个空的变量名**，之后我们就可以在**调用函数的时候向函数内传入一个值**，而这个值将会赋给函数中的那个定义的空白变量，这时就可以在函数中使用这个变量了。

一个**函数中可以在括号中定义很多的接收传入参数的变量**（当然定义各个变量之间需要使用逗号隔开，在调用函数的时候传入参数也是同理）

**PS:**  但是一旦在函数的括号中定义了一个储存传入参数的变量，那么一旦在主函数中调用这个函数时没有传入参数，系统将会报错

在没有对定义的变量进行任何的处理时，这里传入的值和变量之间的对应关系是严格的一一对应，但是python中还有着另一个**关键字参数的定义方式可以更改这个严格的顺序**，它的使用语法不需要对定义的函数进行更改，仅仅需要对于调用函数的时候进行一些更改，**调用函数格式为`调用函数(定义函数中的变量名 = 将要传入参数, 定义函数中的变量名 = 将要传入参数)`**，通过这样的格式就可以实现对于传入参数顺序的一个更改（但是顺序改变依然对应未改顺序前值应传入的变量），而这样的**关键词参数形式可以有助于主函数的可读性**（能够直观的看到每一个传入的参数的去向从而推断出传入这些参数的意义）

如果在传入参数的时候同时使用了位置参数形式以及关键词参数形式，那么关键词参数形式需要总是在位置参数形式的前面出现，否则就会出现报错，不过如果位置参数出现在最前面后，它的后面跟着多少关键词参数就都可以了。

**PS:**  在函数中定义的变量即为局部变量

### 16.3 使用return语句使函数出现返回值

**语法格式:  `return 将要返回的值`**

**PS:**  这里需要注意的是这个return语句后面将要返回的值可以是一个元素，一个变量，还可以是一个表达式（计算式），如果没有使用return语句，但是依然输出这个函数，那么最终的返回值会是None，相当于我们定义的函数后面有一个默认的return语句返回值是None

这是一个例子将上面字典的示例变为函数模块再进行调用输出

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119095850.png" width = "300px"/>



## 十七、处理错误的语句`try`、`except`

**语句使用背景**:  

没有人会希望因为一个用户输入的值与所需要的值不符就使得程序崩溃，这个时候其实更希望的是当用户输入一个无效的值时，程序并未崩溃而是反馈给用户输入值无效的信息 

下面的程序就是一个由于用户输入的值无法被转换为int类型因此引发的错误：

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119102123.png" width = "450px"/>

**PS:**  exit code显示为0则代表程序正常退出，显示为非0则代表程序崩溃

因此我们需要一个语句可以改变这个现状，这就是`try`、`except`

**语法格式:**

```python
try:
    将要执行的一堆语句
except 可能会出现的错误类型:
    代替出现的错误而执行的一堆语句
except 另一种可能出现的错误类型:
    ...
...
```

**PS:**  因为一段代码的用户输入可能会出现很多的错误，因此这个语句中可以使用很多次的except来对每一种错误可能进行不同的代码执行（防止程序崩溃）

**语句执行过程简单描述:**  当程序在遇到try语句时，会先运行语句内的代码，一旦遇到和except中预见的错误类型，就执行对应的except内部的代码，之后程序会正常的结束（或者继续进行）

下面是一个处理错误语句的使用示例

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119103102.png" width = 350px/>

当然一个except中可以**同时捕获多种异常**，我们还可以使用一个**`[Exception]`指代程序可能发生的所有错误**，这里通常是用在最后一个 except 中，这里还有一种方法，**仅仅使用 except 关键字，不写具体要捕获的异常类型**，这种省略异常类型的 except 语句也是可以的，它也同样表示可**捕获所有类型的错误**，一般也是会放在最后一个 except 块

其实在完成对某种或其他多种类型的错误捕获以后，我们可以使用**`as e`**这样的语句，这样可以在出现这个错误以后，在except中**调用错误信息**

**语法规范:**  `except [ (Error1, Error2, ... ) [as e] ]:`

PS:  这里需要补充的一点是我们在看别人写的程序的时候，可能会看到有些程序没有使用`as e`而是使用的`, e`，其实这两个的意思相同，只不过在 Python 2.x 的早期版本中可以使用`, e`这样的语法。

那么这里可以预想到，如果我们一个except可以捕获多种错误信息，那么如何去获知本次处理的是具体的哪一种呢？

我们可以通过调用如下几个属性和方法获取当前处理异常类型的相关信息：

- `args:`  返回异常的错误编号和描述错误原因
- `str(e):`  只返回错误原因
- `repr(e):`  返回全部异常信息







## 十八、注释（comments）

**语法格式:**  `# 要写的注释`

**PS:**  如果要写多行的注释就在每一行的开头都使用这个#

这里还要注意一点，**写注释的时候井号和注释内容之间一般都会加入一个空格**，否则会有波浪线提示

还有就是**注释如果写在其他的代码后面也要和代码之间至少有两个空格的距离**，否则也会有波浪线提示，主要是影响代码的整体视觉



## 十九、类（class）

### 19.1 类初识

在日常的编程中，我们会有一些需要使用的类型是python中没有包含的，因此此时就需要使用class来定义新的类型来模拟我们需要的类型

**对于class的命名惯例（帕斯卡命名惯例）:**  将命名的首字母大写，这样将我们定义的class的名字就可以和我们定义的变量还有函数（首字符小写）进行一个区分，同时在变量及函数的命名中我们会使用下划线代替空格来隔开两个单词，但是在class中，为了分隔多个单词，我们使用将每个独立的单词的首字母大写的方式来分隔每个单词。

**定义类的语法规范:**  

```python
class 我们将要定义的类名（首字母大写）:
    在这里我们可以定义多个函数来作为这个类的方法
```

### 19.2 创建对象

那么在完成类的定义以后，我们就可以使用类中包含的新类型，并且我们可以使用这个类来创建新的对象

这里类相当于创建了一个对象的模板，而对象就相当于是使用这个类的实例

**定义对象的语法规范:  `储存对象 = 类名()`**这样就创建了一个对象，并且将这个对象返回，这时再使用这个储存对象加`.`就可以使用我们在类中定义的方法

当然每一个对象都可以有着它们的**属性**（就类似于属于这个特定的对象的变量），这种语法规范为**`对象.自定义属性 = 某个值`**

一个类可以创建多个对象，虽然这些对象都是由一个类衍生出来的，但是它们事实上是不同的，每个对象再次定义的属性都在严格意义上不相同

**构造（construct）函数:**  构造函数经常被用于创造对象的时候，它可以直接用来**初始化对象的属性**

当构造函数在创造对象的时候被调用的时候，需要调用存在于定义的类中的一个方法**`def __init__ (self, 将要从创造对象中接收到的第一个参数的属性名, ...):`**，接着在这个语句下面使用缩进符写初始化对象的代码**`self.已接收的属性名 = 对应的属性名`**，那么在主函数中创造对象时，语句的格式如下**`储存对象 = 类名(传入的第一个参数, ...)`**，这时我们所创造的对象的属性就定义完成，当然我们可以在创建对象的语句后面再重新设置这个对象的属性。

现在来说一个类中很重要的一个点，在类中，我们创建的每一个方法都应该有一个第一个参数`self`，而这个self事实上就能够得到当前的对象并且对这个对象的属性进行调用

下面是一个使用类并创建对象,并在我们的方法中调用对象属性的一个简单示例

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119125415.png" width = "420px"/>

### 19.3 类中的继承（inheritance）

在python的类定义中，会有这样的一种情况，两个不同的类名中定义了相同的函数，而这就违背了编程中dry的原则（不要重复自己的代码），而事实上之所以不建议在一个程序中重复多段代码的缘故是因为一旦在未来的某个时候发现我们的代码有些缺陷，而这段代码又被重复了多遍，那么你需要对这段出现问题的代码进行多次的重复修改，因此引入了继承的语法。

继承其实就是使用一个父类（parents class）来写入被重复的代码，之后对于需要使用这一段代码的类来说，就使用继承的语法来获得存在于父类的代码，从而避免代码的重复。

**继承语法规范:**  

```python
class 父类的名称:
    重复部分的一段代码

    
class 子类的名称(父类的名称):
    如果这个子类有自己专属的函数，就继续写，如果没有，写一个pass

    
同上...
```

**PS:**  要注意，为了避免warning，建议类与类之间加入两个换行符，还有就是类中不能为空（就是不能一点代码都没有），如果除了继承的代码以外真的没有其他的代码了，就使用pass语句（pass语句代表着没有东西）来结束这一个类，如果类中还有语句，就可以不使用pass语句。



## 二十、模块（modules）

在python中一个模块基本上就是一个带有python代码的文件，这样可以使得我们的python代码更有结构，而且有利于重用代码。

在模块文件中可以存放我们定义的类以及函数，最后使用import引入我们的模块文件

### 20.1 模块的使用方法一

1. 首先，打开项目模板
2. 在当前的文件下新建一个`.py`的文件
3. 将我们定义的类以及函数放入模块
4. 接着在主文件中使用`import 将要引入的模块的名称（不需要扩展名.py）`
5. 之后如果需要使用模块中的无论是类还是函数，都需要先调用其所在的模块名，后面使用`.`继续引用函数或者是类（如果是类可能还要继续使用`.`）

下面是一个示例，这里使用了一个模块，在主函数中使用了模块中的类，函数，并且类中的方法我使用了两种形式调用，一个是创建对象后使用对象调用，另一个是直接调用这个类的方法，然后传入创建的对象（这两个结果一样）

这个是主函数

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119152908.png" width = "500px"/>

这个是模块

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119153030.png" width = "500px"/>

### 20.2 模块的使用方法二

**下面介绍另一种向主函数中引入模块的方式:**

**语法规范:  `from 模组文件名 import `**

这是一个引用了函数以及类的一个例子，这个语法的好处在于一旦在开头导入过一次模块文件以后，之后就能够直接正常使用这些存在于模块中的函数以及类

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119154125.png" width = "500px"/>



## 二十一、包（package）

### 21.1 包初识

包是我们组织代码的另外一种方式，对于一个真正的大项目中，可能会包含数百甚至上千个模块，一旦在主目录中添加所有的模块，主目录中会有太多的文件存在，因此最好的解决办法是将功能相关的模块存放在一个包里面，因此可以说一个包就是一个容器存放着一个文件系统中的多个模块，这个包可以是一个文件夹或者是一个目录（directory），在这个目录下需要新建一个`__init__.py`文件（这是一个规定，这样python解释器看到包含有带有这个名称的文件在的文件夹或者目录时，它会把这个目录当作一个包）

**PS:**  其实pycharm中为我们提供了python package的选项（选择这个选项，pycharm会自动创建一个带有`__init__.py`文件的目录）

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119162129.png" width = "450px"/>

和模块类似，使用`.`来对每一级进行访问，只不过包的访问需要带有目录的一级，示例如下

### 21.2 错误插曲之路径问题

本来像尝试一下使用包的，结果出现了不明的报错

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119170255.png" width = "1000px" height = "65px"/>

之后经过查找资料才明白原来是因为没有选择.py文件，因此修改过程如下

1. 点击这个被标记的按钮

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119170814.png" width = "150px"/>

2. 之后更改这里的路径到目前运行的.py文件，如果name想改的也可以改



<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119171003.png" width = "500px"/>

之后再次运行就能够正常的运行了

**错误后记:  当我回忆为啥会出现路径的错误的时候我想起来我把原来的函数文件删除了**

为了验证我的假设，我再次把我的.py文件删除了，接着重新写了一个包放到主函数中的代码

这次出现了另一个错误

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119172230.png" width = "1000px"/>

然后我去查看了这个pycharm中的运行路径

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119172414.png" width = "450px"/>

原来如此！我已经把app.py删除了，但是路径依然指向这个不存在的文件，所以这两种错误的出现的最终原因都是路径的指向错误，进行更改后，程序就可以正常运行了。

### 21.3 包的使用实例

这只是一个小插曲，那么现在我们接着对于包的知识点进行尝试使用

1. **首先是第一个使用方式（这个就类似于模块的引入）**

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119173410.png" width = "500px"/>

2. **接着是第二种使用方式（此时这个方式就能够省了很多的事）**

   **PS:**  注意这里的用法，我可以使用逗号同时引入类和函数，这个语法格式在模块种同样适用

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210119173914.png" width = "500px"/>

这里在提一下这个第二种使用方式的另外一个表达方式，如果包里面的模块比较多的话，建议不是导入某一个模块里的类和函数，而是直接导入多个模块**`from 包名 import 模块名1, 模块名2, ...`**。

只不过之后的语句就全要使用模块做前缀了



## 二十二、python的内置模块

python会自带一个标准库，里面包含了很多不同功能的模块，也就是说，我们可以直接调用很多的功能，这些功能的标准库大全有着它自己的[官方文档](https://docs.python.org/3.7/py-modindex.html) ，在文档中选择与自己下载的python版本对应的文档就可以开始眼花缭乱的模块学习了（当然不需要学习全部的python模块，选择性的学习一些自己需要的模块就可以了）

**下面来介绍一个简单的模块random**

1. **`random.random()`:**  这个方法可以自动生成一个0到1之间的数值
2. **`random.randint()`:**  对于这个方法，我们可以规定这个随机数生成的范围，这就需要我们传入两个参数来规定这个随机数生成的上限和下限、
3. **`random.choice()`:**  这个方法可以随机的选出列表中的某一个元素，传入的参数是对应的列表名。

### 22.1 文件操作的辅助模块

**当然python的内置模块种还有一个很好的模块是对文件进行操作的模块pathlib**

1. 首先是**对pathlib的引入`from pathlib import Path`**

   **PS:**  这里应该注意到一个非同寻常的事情，这个Path的首字母是大写，这意味着这个Path是一个类，因此要给他创建一个对象

2. 当然，创建`Path()`的时候，如果不向括号中传入目录的话，它会默认引用当前文件存在目录，如果要传入另一个目录或者文件的话，要使用双引号来包括文件名

   那么现在我为这个类创建了一个**path对象**，下面来试一下这个对象中有的一些方法

   - **`path.exsts()`:**  这个方法是用来**搜索创建对象时传入的文件或者是否存在**的方法，这个方法将只是返回一个布尔值（Ture表示存在，False表示不存在）

   - **`path.mkdir()`:**  这个方法的全称是`make directory`，可以看出这个方法的意思是**创建目录**。这个目录的返回值是None，也就是说，这个方法事实上不会返回任何的值，它会在当前的项目里创建一个目录，而这个目录的名字由创建对象的时候括号里传入的目录名来决定

   - **`path.rmdir()`:**  和上面的类比，这个方法的全称是`remove directory`，可以看出，这个方法是用来**删除文件**的，那么删除的文件也是由创建对象的时候括号内传入的目录名来决定

   - **`payh.glob()`:**  在这个方法中我们可以**搜索目录和文件**，首先传入的第一个参数是一个字符串，我们用这个字符串定义一种搜索模式，如果我们输入字符星号`'*'`，这意味着所有的文件和所有的目录；如果我们输入`'*.拓展名'`，那么就意味着将会搜索所有包含这个拓展名的文件；如果我们输入`'*.*'`，那么我们就之后获取当前目录中的文件

     **PS:** 这个方法中我们得到的并不是各个文件或目录名，而是一个对象，叫做`generator object`。因此如果我们想要去看这个对象中的东西，可以通过遍历的方式来print每一次的值查看



## 二十三、文件操作

### 23.1 编码格式

**首先，为什么要去学习编码格式呢？**

因为我们在操作我们的文本文件的时候，文件名大多数都是中文，这个时候就经常会碰到中文乱码的问题，因此需要去了解编码格式的问题。

- python的解释器使用的是Unicode
- .py文件在磁盘上的存储使用的是UTF-8的存储方式

这里对于部分支持中文的编码格式进行一个简单的罗列：GB2312、GBK、GB18030、UTF-8

### 23.2 文件读写

**文件读写是一种同步IO（Input/Output）操作**，即输入和输出。**同步IO操作**简单来说是指当程序暂停等待IO的结果后再继续执行，而有了同步IO操作就会有**异步IO操作**，异步IO操作是指程序不等待IO结果继续执行。

**PS:**  这里要注意的是IO操作中无论是I还是O都是单向独立进行的

**下面来简单的了解一下文件读写的操作流程:**

1. python解释代码

2. 通过操作系统打开文件或者新建文件

3. 对于打开的文件进行读（也可以写），对于新建的文件写

   **PS:**  这里的读是指从文件中将文件的数据输入到程序中（内存）当文件读入后会在程序中创建一个对象（这个映射的是操作系统中的文件），写是指将数据从内存输出到文件中

4. 关闭操作系统资源

那么理解了文件读写的大致流程以后，这里需要说一个很重要的事实，在现代操作系统中，是不允许普通的程序直接操作磁盘的，这就可以解释为什么python文件的读写还要费很大的劲从磁盘中将文件数据读入还要在程序中创建文件对象最终还要将数据从内存输出回文件中了，**因此总的来说，文件的读取实质上是通过IO流将磁盘文件中的内容与程序中的对象中的内容进行同步，而非直接在磁盘中操作文件**

**文件的读取:**

**使用的函数为`open()`函数，它的语法规则是`file_name = open('real_file_name' [,mode, encoding])`**

- file_name是被创建的文件对象名
- open是创建文件对象函数
- real_file_name是将要创建或打开的文件名称，不要忘记加拓展名
- mode是选择模式，这里打开模式默认为只读模式
- encoding是文本文件中字符的编写格式，默认为GBK

**mode的常用模式:**

这里的指针指向的位置的意义在后面文件操作的其他方法里会进行介绍

1. 'r'，以**只读模式**打开文件，**指针指向开头**

2. 'w'，以**只写模式**打开文件，如果文件不存在则创建文件，如果文件存在则直接覆盖文件原有内容，**指针指向开头**

3. 'a'，以**追加模式**打开文件，如果文件不存在则创建文件，此时**指针指向开头**；如果文件存在则在文件末尾追加内容，此时**指针指向文件末尾**

4. '+'，以**读写方式**打开文件，它**不可以单独使用，必须要和其他模式一同使用**，比如'a+'，意思是这个文件既可以写也可以读，而且写是在文件的末尾写（不更改原文件的内容）

5. 'b'，这个很有趣！是**用二进制的方式打开文件**，这个模式并**不单独使用，会和其他模式联合使用**，比如'rb'读二进制文件，'wb'写二进制文件。

   **那么我为什么会说这个很有趣呢？因为图片可以使用二进制文件打开！**

   **也就是说，通过这个模式，我们完全可以实现对于文件的复制**

   ```python
   #比如现在我们有一个图片叫做img.png
   src_img = open('img.png','rb')
   copy_img_file = open('copy.png','wb')
   copy_img_file.write(src_img.read())
   src_img.close()
   copy_img_file.close()
   ```

   **PS:**  `.read()`方法的意思是读取文件的全部内容，即返回文件内所有内容，如果向括号中传入一个整型数值，那么就相当于规定读取文章内的内容数

   **代码分析:**

   1. 首先以二进制只读的方式打开了一个img图片，并将这个图片以二进制方式将信息全部储存在src_img这个对象中
   2. 接着由于没有copy.png图片，我们在磁盘中创建了一个copy.png文件，并以二进制只写的方式打开它，并将其传入copy_img_file对象中
   3. 接着我们调用`.write()`方法向copy.png对应的对象copy_img_file中写入src_img对象返回的内部储存的所有img图片的二进制信息
   4. 最后关闭这两个对象
   5. 完成了图片的拷贝

**文件的写入格式:`创建的文件对象名.write()`**

**PS:**  在括号内可以添加将要写入文件的内容，写入的方式和open函数的mode有关

**文件的关闭格式:  `创建的文件对象名.close()`**，这个操作的意义是会把缓冲区的内容写入文件，关闭文件并释放操作系统的资源

**PS:**  一旦使用这个方法后，就无法再对文件对象进行操作（因为这个对象已经不存在），否则会报错

### 23.3 文件操作的其他方法

这里要先说明如果是读性质的方法需要在创建文件对象的时候选择和读相关的mode，如果是写性质的方法则需要在创建文件对象的时候选择和写相关的mode

1. **`file.readline()`:**  使用这个方法仅会**读取文件中的一行内容**

2. **`file.readlines()`:**  这个方法会将**文本文件中的每一行都作为一个独立的字符串对象，并将这些对象放入一个列表中返回**

   **PS:**  这里有一个有意思的事情是，每次读取一行字符串的时候，除了最后一行以外，每一个字符串的末尾都有一个`\n`换行符

3. **`file.writelines()`:**  这个方法中可以传入列表，并**将这个列表写入对应的文件**，如果有换行符就一行一行的写，如果没有就全部连接起来写入文件

4. **`file.seek()`:**  这个方法可以**移动文件中的指针**，传入的参数就是指针移动的距离

   **PS:**  一开始指针指在文件的最开头，即第一个字符的前面，还有就是我们的中文一个字占据两个字节，因此移动指针的时候，如果一次移动一个字节就会报错UnicodeDecodeError，因此使用这个方法操作中文的时候要一次移动偶数位个字节

5. **`file.tell()`:**  这个方法可以**返回文件当前指针的位置**

6. **`file.flush()`:**  这个方法会**把缓冲区的内容写入文件，但是并不关闭文件**，即文件资源并未释放

   **PS:**  这个方法使用后，文件依然可以被继续操作，但是无论如何**不要忘记最后一定要close**

### 23.3 上下文管理器（with语句）

**语法格式:  `with open('文件名', '打开模式') as 创建的储存文件对象`**

**意义:**  当离开with语句的时候程序会自动释放资源（无需再次手动关闭，避免系统资源的浪费）

### 23.4 OS模块（python内置模块）

这个OS模块中的方法都是对操作系统进行操作的，下面进行一些简单的介绍

**PS:**  别忘了**先导入os模块`import os`**，还有这里的路径均可使用相对路径或者绝对路径

1. **`os.system()`:**  这个方法是用来**打开系统中的应用程序**，传入的参数就是将要打开系统中应用程序（不要忘了使用单引号进行包裹），而其实这个方法就相当于在Windows下直接搜索相应文件并打开的操作相似
2. **`os.startfile()`:**  这个方法也是**打开系统中的可执行文件**，方法的括号中传入的是将要被打开的文件的绝对路径（也要使用单引号进行包裹），别忘了路径中的`\`需要写两个（一个用作转义字符）
3. **`os.getcwd()`:**  这个方法**返回当前的工作目录**，不需要传入参数
4. **`os.listdir()`:**  这个方法**返回指定路径下的所有文件和所有目录信息（名称和对应拓展名）**，如果是使用相对路径一定要注意指定路径和当前工作文件之间的关系
5. **`os.mkdir()`:**  这个方法的作用是**创建目录**，如果不写将要创建的路径就默认和当前工作文件在同一级目录下
6. **`os.makedirs()`:**  这个方法用于**创建多级目录**，如果不写将要创建的路径就默认和当前工作文件在同一级目录下
7. **`os.rmdir()`:**  **删除指定路径的目录**，如果不写将要删除的路径就默认和当前工作文件在同一级目录下
8. **`os.removedirs()`:**  **删除多级目录**，如果不写将要删除的路径就默认和当前工作文件在同一级目录下
9. **`os.chdir()`:**  **向方法中传入一个参数（路径）**，即可更改当前的工作目录为设定的路径



