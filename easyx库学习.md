# easyx库学习
   * [easyx库学习](#easyx库学习)
      * [一、Easy x简介](#一easy-x简介)
         * [1.1 注释之API](#11-注释之api)
      * [二、使用背景](#二使用背景)
      * [三、easyx库安装原理](#三easyx库安装原理)
         * [3.1 注释之.lib](#31-注释之lib)
            * [3.1.1 对于lib和dll的区分：](#311-对于lib和dll的区分)
      * [四、使用之前的提示](#四使用之前的提示)
      * [五、easy库入门篇](#五easy库入门篇)
         * [5.1 画布创建与关闭](#51-画布创建与关闭)
            * [5.1.1 画布创建和关闭的基本操作步骤如下：](#511-画布创建和关闭的基本操作步骤如下)
            * [5.1.2 对于这个windows窗口（画布）进行一些简单的介绍：](#512-对于这个windows窗口画布进行一些简单的介绍)
         * [5.2 窗口颜色](#52-窗口颜色)
            * [5.2.1 窗口颜色设定的基本操作](#521-窗口颜色设定的基本操作)
            * [5.2.1 setbkcolor函数中传入的颜色参数进一步说明](#521-setbkcolor函数中传入的颜色参数进一步说明)
         * [5.3 文字输出](#53-文字输出)
            * [5.3.1 简单的文字输出](#531-简单的文字输出)
            * [5.3.2 文字的大小以及字体的更改](#532-文字的大小以及字体的更改)
         * [5.4 简单绘图](#54-简单绘图)
            * [5.4.1 画线函数](#541-画线函数)
            * [5.4.2 画圆函数](#542-画圆函数)
            * [5.4.3 画矩形函数](#543-画矩形函数)
            * [5.4.4 画椭圆函数](#544-画椭圆函数)
         * [5.5 图像进行简单移动](#55-图像进行简单移动)
         * [5.6 图片显示](#56-图片显示)
      * [六、入门之进阶篇](#六入门之进阶篇)
         * [6.1 颜色使用之进阶篇](#61-颜色使用之进阶篇)
         * [6.2 图形颜色样式之进阶篇](#62-图形颜色样式之进阶篇)
         * [6.3 图形绘制之进阶篇](#63-图形绘制之进阶篇)
         * [6.4 文字输出之进阶篇](#64-文字输出之进阶篇)
         * [6.5 进阶知识之基础鼠标相关函数](#65-进阶知识之基础鼠标相关函数)
            * [6.5.1 主要内容](#651-主要内容)
            * [6.5.2 由鼠标相关函数联想到的测屏大致坐标的小技巧](#652-由鼠标相关函数联想到的测屏大致坐标的小技巧)
         * [6.6 进阶知识之基础解决闪屏的函数](#66-进阶知识之基础解决闪屏的函数)
         * [6.7 进阶知识之基础操作窗口函数](#67-进阶知识之基础操作窗口函数)
      * [七、练习过程中的error汇总](#七练习过程中的error汇总)
      * [八、题外的辅助音乐库之入门篇](#八题外的辅助音乐库之入门篇)
      * [九、题外的辅助键盘消息函数之入门篇](#九题外的辅助键盘消息函数之入门篇)
      * [参考资料](#参考资料)

## 一、Easy x简介

Easyx是**基于Windows图形编辑**的一个图形库，是**对Windows进行了封装的一些函数**，最终效果的产生都会由Windows的**底层API实现**。



### 1.1 注释之API

Windows 这个多作业系统除了协调应用程序的执行、分配内存、管理资源之外， 它同时也是一个很大的服务中心，调用这个服务中心的各种服务（每一种服务就是一个函数），可以帮应用程式达到开启视窗、描绘图形、使用周边设备等目的，由于这些函数服务的对象是应用程序（Application）， 所以便称之为 Application Programming Interface，简称 API 函数。



## 二、使用背景

在学校进行c语言程序设计项目的时候，我们小组选择的是推箱子项目，但是在设计真正的完成以后，发现没有完成设想设想中很好的图像效果，因此我在网络上进行了资料的查阅，为了寻找一个可以替代dos界面的可视化图形界面，因此才会对easyx库函数感兴趣。



## 三、easyx库安装原理

easyx安装程序会将库函数所需的.h和.lib文件自动安装至 VC 的 include 和 lib 文件夹内（Easyx库采用静态链接方式，不包含动态数据库)。



### 3.1 注释之`.lib`

.lib是一个静态数据库，目前我的理解就是easyx中各种函数要运行所需要的对应内部语句（这样easyx库的各种函数就如同printf函数，scanf函数一样可以函数内部的代码隐藏，并且可以正常调用了）

这里再多说一点数据库的内容：**静态数据库（.lib文件）**和**动态数据库（.dll文件）**。



#### 3.1.1 对于lib和dll的区分：

如果是简单来说，可以描述为lib是编译时用到的，dll是运行时用到的（当然这个并不正确，事实上动态链接同样需要这lib的参与，此时lib中会记录一些关于dll中函数入口和位置的信息，dll文件中是函数的具体内容）

下面来分别说说两种数据库的**特点:**

1. **静态数据库的静态编译**

   静态编译将导出声明和实现都放在lib中。编译时所有代码都嵌入到调用库函数的程序进行编译

   **静态数据库有着自己的优缺点:**

   - 静态编译的优点是编写出来的程序不需要调用DLL（动态编译）和载入函数，直接可以当成程序的一部分来使用。
   - 静态编译的缺点也是显而易见的，使用静态编译的程序体积会比动态编译大，原因是函数的实现被嵌入为程序代码的一部分，失去了动态库的灵活性，如果是对于一个软件来说，如果使用静态数据库的话，在发布新版本时要发布新的应用程序才行。

2. **动态数据库的动态编译**

   动态LIB文件相当于一个C语言中的h文件，是函数导出部分的声明，而不将实现过程嵌入到程序本身中，编译后只是将函数地址存在宿主程序中，运行到调用函数是调用DLL并载入函数来实现函数的具体操作。

   **动态数据库有着显著的优点：**

   - 当多个使用一个相同的dll文件的程序同时运行的时候，只需要占用一个dll文件的空间即可，因此它可以减少对计算机空间资源的使用
   - 由于一个dll文件可以有着自己独立的功能，因此对于一个程序的某个模块的功能的优化只需发布对应功能模块优化后的dll文件即可，当然如果有多个应用程序均使用这个dll文件，那么对于一个dll文件的优化可以对这多个程序均进行了提升。

当然有关于dll以及lib的更多内容可以去参考[微软的文档](https://docs.microsoft.com/zh-cn/troubleshoot/windows-client/deployment/dynamic-link-library)和一个[简述两者区别的博客](http://www.cppblog.com/amazon/archive/2009/09/04/95318.html)



## 四、使用之前的提示

easyx库函数需要额外在easyx官网上下载函数库的[安装包](https://easyx.cn/downloads/view.aspx?id=10)，并导入VC或VS系列的编译器才可以使用。

在使用visual stdio的时候EasyX 也可以在 Win32 Application 项目上使用。但是需要注意的是，Win32 Application 项目没有控制台，因此无法使用控制台相关的函数（但是有很多效果是需要控制台相关的函数的，因此即使能用easyx也不推荐创建这个项目），当然一般推荐使用创建空项目的功能。

对于easyx库函数的使用，需要创建cpp源文件（如果使用c源文件会报错），不过即使是使用cpp文件，我们依然可以使用c语言的语法。

**PS:** 本次学习前期使用的是vc++6.0,后期使用的是visual stdio 2013



## 五、easy库入门篇

### 5.1 画布创建与关闭

#### 5.1.1 画布创建和关闭的基本操作步骤如下：

1. 使用easyx库函数所需要引用的头文件是`gaphics.h`。

2. 创建画布的函数initgraph的括号中的两个参数分别是将要创建的窗口的宽度和长度。

   **PS:** 对于窗口创建的大小的控制，可以通过之前在学习css中学到的使用截图工具的方式来模拟需要创建的窗口大小，之后再通过截图工具中返还的测量值来看它的实际像素即可完成对窗口大小的精确设定。

3. 使用getchar函数的作用是为了使得程序等待用户进行一个输入再进行下一步的操作，这样可以使得画布在窗口界面做停留，如果缺少这个函数，那么画布会一闪就立刻关闭。

4. 之后需要closegraph函数关闭画布。

经过上述的步骤就可以创建一个windows窗口，而不再是使用原来的dos窗口，未来的各种操作都将在这个窗口下完成。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/创建画布.png" style="zoom: 50%;" />



#### 5.1.2 对于这个windows窗口（画布）进行一些简单的介绍：

1. 这个窗口的各种图像的呈现需要借助坐标的设定来确定所需要的图像的输出位置，坐标系的建立是以画布的右上角为坐标原点，向下为y轴的正半轴，向右为x轴的正半轴，进行坐标系建立。

2. 因此几乎所有的图形函数都有着两个同样的参数，即画布内的精确坐标（x，y）。



### 5.2 窗口颜色

#### 5.2.1 窗口颜色设定的基本操作

窗口背景的颜色设置，使用的是setbkcolor函数，当然为了使得背景颜色正常显示，需要在这个语句的结尾加上cleardevice函数

**PS:** 如果没有在背景颜色函数的后面加入cleardevice函数（清除图形屏幕），无论是删除或者是说将这个函数放在背景颜色函数的前面，结果都将是背景颜色无法正常显示（下面的图片是我删除cleardevice函数造成的结果）

这种情况出现的原因是虽然已通过setbkcolor设置背景色，但是事实上并不会改变现有背景色，而**只改变背景色的设定值**，但是背景已经在画布生成的同时就输出了默认的数值，因此之后需要再次清空当前的背景颜色以后才会显示新设置的背景颜色

因此才会需要在设置背景色后执行 cleardevice() 函数。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/没有加入cleardevice().png" style="zoom: 50%;" />

<img src="https://gitee.com/gritandsea/picture/raw/master/img/窗口颜色设置.png" style="zoom: 50%;" />



#### 5.2.1 setbkcolor函数中传入的颜色参数进一步说明

setbkcolor和css中的颜色设定一样，并没有仅仅局限于只是能够通过英语单词的方式进行颜色的设置，它同样可以通过RGB的三原色调色完成更加细致的颜色设定

对于RGB三原色的调色也并不是通过数据一个个慢慢尝试完成的，调试，它同样可以通过电脑中自带的最简单的画图工具进行辅助调色，通过自定义的颜色选择，直接可以读出它所对应的RGB数值。

示例如下：

<img src="https://gitee.com/gritandsea/picture/raw/master/img/调色示例.png" style="zoom: 33%;" />

<img src="https://gitee.com/gritandsea/picture/raw/master/img/三原色调色示范.png" style="zoom: 50%;" />

**那么为什么RGB是三个数值的最大值都是256呢？**

在使用颜色的时候，可以选中任意颜色单词，右击，在菜单栏中选择“转到定义”，可以进入easyx库中看库中的内部定义。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/颜色定义.png" style="zoom:50%;" />

其中可以看到颜色是看利用16进制数字来进行表示的，其中前两位代表蓝色，中间两位代表绿色，最后两位代表红色。

这样就可以理解为什么RGB调色每一个数字的最大值是256了，因为这个颜色数字是通过16进制的数字进行表示的，而一个颜色有两个数字表示，即为16乘16种情况，这样总共的情况数就是256种了。

同时看到了16进制的颜色表示，这也代表着颜色其实不止有英文大写表示、RGB三原色10进制配比表示，同样可以使用16进制的数据进行表示。



###  5.3 文字输出

**注:** 文字窗口只能显示字符串

#### 5.3.1 简单的文字输出

利用outtextxy函数，函数内的三个参数分别为文字输出的x、y轴坐标，以及字符串的内容。

如果要让文字出现在背景之前使得文字先输出，之后文字消失，变成背景，那么需要先输入outtextxy函数，之后使用Sleep函数使得文字在画布上延时一段时间，再进行清屏和背景颜色覆盖。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/文字先输出.png" style="zoom: 50%;" />

**`sleep()`函数:** sleep函数的作用是告知系统在执行到这一条语句之后使得程序在当前位置停留设定的时间（sleep函数括号中数值的**单位是毫秒**）。

如果想让文字显示在背景上，则需要先重新生成新的背景后再输出文字，这就需要将outtextxy函数置于cleardevice函数的下方

<img src="https://gitee.com/gritandsea/picture/raw/master/img/文字在背景之后.png" style="zoom: 50%;" />

**文字输出的方法归纳:** 如果将outtextxy函数置于setbkcolor函数和cleardevice函数之间，那么文字依然会被cleardevice函数清屏，因此如果想让文字正确的显示，就需要**规避被清屏的问题**，一个是在清屏函数的后面再执行文字的输出，另一个是先执行文字的输出，之后延迟清屏函数的执行。



#### 5.3.2 文字的大小以及字体的更改

使用settextstyle函数，函数内可以设置的三个参数为文字的长、宽、和字体。

**PS:** 需要注意的是字体的格式函数要**先于**文字输出函数之前执行，这样才能先修改文字的各项参数。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/字体格式修改.png" style="zoom:33%;" />



### 5.4 简单绘图

#### 5.4.1 画线函数

- **`line()`函数:** 用来设定线的起始到终止点，内部参数前两个是x、y轴确定直线起始点，后两个参数是x、y轴确定直线终点。

- **`setlinecolor()`函数:** 可以设定线的颜色，颜色的定义使用大写单词。

  **PS:** 经过尝试，似乎目前只可以用颜色定义，没有找到合法的其他定义方法。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/图形绘制.png" style="zoom: 50%;" />



#### 5.4.2 画圆函数

- **`circle()`函数:** 空心圆的参数前两个通过确定x、y轴坐标来确定圆心坐标，第三个参数确定画圆半径。

  <img src="https://gitee.com/gritandsea/picture/raw/master/img/画圆函数.png" style="zoom: 50%;" />

- **`setfillcolor()`函数:** 作用是对将要画出的实心圆的内部颜色数据进行设定，函数的参数是与预期颜色相对应的英文大写。

- **`fillcircle()`函数:** 作用是创建一个实心圆，其中，填充颜色是由填充颜色函数决定的，函数中的另外三个参数与空心圆函数的参数相同。

  <img src="https://gitee.com/gritandsea/picture/raw/master/img/填充圆.png" style="zoom: 50%;" />



#### 5.4.3 画矩形函数

- **`rectangle()`函数:** 共需要两个位置坐标，即矩形的左上角以及矩形的右下角；共细分为四个小参数，一对x、y轴坐标确定一个基准点。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/矩形画图函数.png" style="zoom:50%;" />



#### 5.4.4 画椭圆函数

- **`ellipse()`函数:** 可以画出无填充的椭圆，这个椭圆的坐标确定很有意思，是通过椭圆外切矩形的左上角x、y轴坐标以及右下角x、y轴坐标进行的确认

<img src="https://gitee.com/gritandsea/picture/raw/master/img/椭圆.png" style="zoom:50%;" />



### 5.5 图像进行简单移动

通过目前所初步了解的一些简单的c语言语句，可以先对一个图形的位置设定一个相应的变量，坐标通过while循环来使得图形的坐标进行不断地变换，从而实现移动效果。

而且移动可以出现不同的效果（主要的不同之处在于是否每一次都使用清屏函数）

- **图形移动并留下痕迹**

<img src="https://gitee.com/gritandsea/picture/raw/master/img/图形移动有轨迹.png" style="zoom:50%;" />

- **图形移动不留痕迹**

<img src="https://gitee.com/gritandsea/picture/raw/master/img/图形移动带轨迹.png" style="zoom:50%;" />



### 5.6 图片显示

首先需要将要显示的图片放置与cpp源文件同目录

- **`IMAGE()`函数:** 用来定义一个可以储存图片的变量，需要为所定义的变量设定一个标志（这个标志事实上就是为这个图片起名字，之后在程序中应用时，都是通过这个名字来访问内部的值）

- **`loadimage()`函数:** 作用是加载图片，首先引用图片的地址（通过取地址符对保存图片的变量地址进行引用），之后就使用双引号引用图片关于源文件cpp的相对路径（目的是将图片存入这个变量所在地址）或者绝对路径（不推荐），之后可以在加载图片的同时对于将要存入图片变量的图片的大小进行重置，规定它的长和宽（但是这样如果对原图片的长宽比例不清除可能会使得图片失真）。

  **PS:** 很可能在使用这个函数的时候出现error C2665,解决办法详见文末的error汇总

- **`putimage()`函数:** 在当前画布上绘制存入图像变量中的图像，函数中的前两个参数是通过x、y轴坐标确定图片左上角的位置，最后一个参数是通过图片变量的地址来引用图片

  下图是没有设定图片大小（即直接使用图片原始大小）后图片绘制在画布上的效果。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/图片显示.png" style="zoom:50%;" />

这个是对图片进行大小设定（和画布一样大）以后的效果。通过下面的这个照片可以看出通过这个方式更改图片大小的一个弊端，容易由于对图片的原始比例没有把控而产生拉伸效果，影响图片的展示。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/图片大小设置.png" style="zoom:50%;" />

当然有另外的一种方式，在加载图片后，对于加载的图片通过定义的宽度变量以及长度变量，以img.getwidth以及img.getheight语句来获取图片的参数，之后再进行画布的创建（这样画布的大小就可以直接利用已经获取的图片长宽参数来相应创建），这样可以在某种意义上避免图片拉伸的问题，但是很有可能由于图片本身很大，而笔记本电脑屏幕有点小，因此无法将图片完整的显示。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/图片显示原大小.png" style="zoom:50%;" />



## 六、入门之进阶篇

### 6.1 颜色使用之进阶篇

除了在基础篇中提到的使用颜色对应单词大写来表示颜色（预定义常量表示颜色）、使用16进制数字表示颜色、使用RGB三原色合成颜色以外，这里将介绍两个新的颜色表示方式：HSL转化为RGB、HSV转化为RGB。

- HSLtoRGB
- HSVtoRGB

以上两个函数都是应用在设置背景函数内部作为颜色设定函数使用，使用方式很简单，和RGB设定相仿，在函数的括号内设定对应的三个参数的数值即可。



**HSL:**  **H是色相**，即组成可见光谱的单色（红色在 0 度，绿色在 120 度，蓝色在 240 度）。**S是饱和度**，是指色彩的纯度，饱和度越高色彩越纯越浓，饱和度越低则色彩变灰变淡。等于 0 时为灰色。在最大饱和度 1 时，具有最纯的色光。**L是亮度**，是色彩的明暗程度。等于 0 时为黑色，等于 0.5 时是色彩最鲜明的状态，等于 1 时为白色。

**参照下面的图片有利于辅助理解**

![](https://gitee.com/gritandsea/picture/raw/master/img/HSL内涵.jpg)



**与HSL知识相关的程序示例（easyx库示例）**

```c
#include <graphics.h>
#include <conio.h>
int main()
{
	// 创建绘图窗口
	initgraph(640, 480);
	// 画渐变的天空(通过亮度逐渐增加)
	float H = 190;		// 色相
	float S = 1;		// 饱和度
	float L = 0.7f;		// 亮度
	for (int y = 0; y < 480; y++)
	{
		L += 0.0005f;
		setlinecolor(HSLtoRGB(H, S, L));
		line(0, y, 639, y);
	}
	// 画彩虹(通过色相逐渐增加)
	H = 0;
	S = 1;
	L = 0.5f;
	setlinestyle(PS_SOLID, 2);		// 设置线宽为 2
	for (int r = 400; r > 344; r--)
	{
		H += 5;
		setlinecolor(HSLtoRGB(H, S, L));
		circle(500, 480, r);
	}
	// 按任意键退出
	_getch();
	closegraph();
	return 0;
}

```

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210117100150.png" style="zoom:50%;" />



**代码分析**

- **画渐变的天空**

  利用for循环，设定将要画的线x坐标从屏幕的最左端到屏幕的最右端进行绘制，每一轮y轴坐标都进行加一，以此进行全屏的直线覆盖。在每一轮的循环中，自动增加的不仅仅有y轴坐标，还有直线的颜色亮度，每一轮亮度都进行一定程度的增加，这样每一轮直线的颜色数值中的亮度每一轮也同样进行了对应的刷新，产生背景由中亮到亮的渐变效果。

- **画彩虹**

  在这段代码中引入了一个新的函数setlinestyle函数（顾名思义，对所所绘制的直线的风格进行修改），这里面引用的参数一共有两个，第一个是画线的样式（此代码使用的是实线样式，如果平时不常用easyx库，不推荐将这些全记下来，每次需要使用的时候查阅一下手册就可以了。不过可以将这个线形的样式和AUTOCAD绘图软件中的图层线形相结合记忆，利于理解记忆，因为它们的单词组成相似。），第二个规定的是线宽，单位默认为像素。

  这段代码的大致思路与上面的渐变天空的思路相仿，同样是利用for循环对数值进行逐步增加，只不过这里是将色相数值逐渐增大以及对圆的半径进行逐渐的缩小（不要忘记每一次都使用函数刷新线的颜色）



**之后我对于代码中的_getch()函数有些不清楚，在这里进行一个小记录**

带下划线的目的是为了防止用户定义的函数和函数库的函数重名冲突，所以直接使用也是可以的。

**PS:** 此函数的使用目的主要是使得画布在显示界面做停留



**HSV:** H、S的意义和和HSL中的相同，只是在V上面有了变化，它是明度，通俗来说，这个参数舍去了亮度大于0.5的颜色，它的参数1即为颜色最鲜艳的时候



**下面同样引入图片辅助理解**

<img src="https://gitee.com/gritandsea/picture/raw/master/img/HSV内涵.jpg"  />



### 6.2 图形颜色样式之进阶篇

- **`setfillstyle()`函数：**可以作用在这条语句执行后的每一条有填充效果的图形绘制中

  函数参数有多种形式，当没有使用此函数的情况下，**默认是固实填充（BS_SOLID）**。

  如果在setfillstyle函数内使用固实填充或者**不填充（BS_NULL）**语句

  **PS:** 如果仅仅使用这个参数个人认为不如用不使用此函数以及使用纯粹的画圆函数替代

  如果使用**图案填充（BS_HATCHED）**，则需要同时设定第二个参数（填充图案样式），这个具体样式可以参考[easyx帮助文档](https://docs.easyx.cn/zh-cn/setfillstyle)

  如果使用**自定义图案填充**，那么共有两种填充方案**BS_PATTERN和BS_DIBPATTERN**（两个参数之间的具体区别在于前一个IMAGE 中的黑色（BLACK）对应背景区域，非黑色对应图案区域。图案区域的颜色由函数 settextcolor 设置，而后一个直接填充整个背景），**同时需要设定第二个参数NULL**（目的是把第二个本应输入的图案样式参数隔过去），**再取图片变量的地址给函数内的指针**。

  **tip:** 使用图片变量时不要忘记先定义一个图片变量，在加载一个图片到这个图片变量里面。

  

  **示例**
  
  <img src="https://gitee.com/gritandsea/picture/raw/master/img/图片图形填充.png" style="zoom:50%;" />
  
  
  
  **对于BS_PATTERN和BS_DIBPATTERN的细节分辨**
  
  - 当 style 为 BS_PATTERN 时，ppattern 指向的 IMAGE 对象表示自定义填充图案，IMAGE 中的黑色（BLACK）对应背景区域，非黑色对应图案区域。图案区域的颜色由函数 [settextcolor](https://docs.easyx.cn/zh-cn/settextcolor) 设置。
  
  - 当 style 为 BS_DIBPATTERN 时，ppattern 指向的 IMAGE 对象表示自定义填充图像，以该图像为填充单元实施填充。
  
    

**关于setfillcolor函数的提示**

如果填充图形的填充格式是图案填充，那么setfillcolor函数控制的颜色参数就是填充图案的填充线。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/填充线改变.png" style="zoom:50%;" />



**改变cleardevice函数所处位置产生的效果尝试**

当cleardevice函数位置处于设置背景颜色函数的前面（其实可以理解为没有使用清屏函数），对于填充图形的填充颜色会默认使用已经更改的背景颜色，但是画布的背景颜色没有更改

<img src="https://gitee.com/gritandsea/picture/raw/master/img/清屏函数所处位置不同的尝试.png" style="zoom:50%;" />



当在正确位置使用cleardevice函数，即在设置完背景以后再进行清屏，那么效果就变成预期效果

<img src="https://gitee.com/gritandsea/picture/raw/master/img/清屏函数使用.png" style="zoom:50%;" />



### 6.3 图形绘制之进阶篇

对于arc函数（绘制椭圆弧）、pie和solidpie还有fillpie函数（各种扇形）这样不实用的函数就不再深入学习了。

各种形状的样式内部的参数和入门篇中的大同小异，只是效果有所差异，因此对于这部分都不再详细探究，需要使用时再做查阅。



### 6.4 文字输出之进阶篇

- **`drawtext()`函数：**用于在**指定形状区域**内以**指定格式**输出字符串

  首先需要为将要输出的字符串设定一个输出空间区域（一个矩形区域）

  需要RECT r={。。。。。。}的语句，其中大括号中就是一个对矩形的形状进行定义的，通过坐标确定左上角和右下角。

  接下来drawtext函数中的所有行为将会全部在这个矩形框中完成。

  <img src="https://gitee.com/gritandsea/picture/raw/master/img/格式化输出文字语句.png" style="zoom:50%;" />

  

  **常用的格式的语句如下:**

  - **DT_BOTTOM**

    调整文字位置到矩形底部，仅当和 DT_SINGLELINE 一起使用时有效。

  - **DT_CENTER**

    文字水平居中。

  - **DT_LEFT**

    文字左对齐。

  - **DT_RIGHT**

    文字右对齐。

  - **DT_SINGLELINE**

    使文字显示在一行。回车和换行符都无效。

  - **DT_TOP**

    文字顶部对齐。

  - **DT_VCENTER**

    文字垂直居中。仅当和 DT_SINGLELINE 一起使用时有效。

  - **DT_WORDBREAK**

    自动换行。当文字超过右边界时会自动换行(不拆开单词)。回车符同样可以换行。
    
    

- **`settextstyle()`函数:** 用于设定当前字体样式

  常用的是前三个参数，分别是设定字体的高度，字符的平均宽度（一般都是写0，这样会自动调整比例），第三个是将要使用的字体名称

  一共有提示中的如下参数可以选择，但是很明显，除了上面使用到的参数以外，下面的这些参数都不是特别实用
  
  <img src="https://gitee.com/gritandsea/picture/raw/master/img/字体样式函数.png" style="zoom:50%;" />

  为了对settextstyle函数有一个更加直观了解，还是自己动手code一下比较靠谱，这次为了让效果更加突出，我采用了将宽度变为高度的二倍，代码运行效果和预期相符如下：

  <img src="https://gitee.com/gritandsea/picture/raw/master/img/字体样式尝试.png" style="zoom:50%;" />

  将比例设定的正常一点的代码效果：

  <img src="https://gitee.com/gritandsea/picture/raw/master/img/正常格式.png" style="zoom:50%;" />

  因此其实字的粗细不一定需要通过控制文字的线条完成更改，其实完全可以通过更改字体类型（比如黑体就会比宋体要粗）这种的方式来更改文字线条的粗细。
  
  

### 6.5 进阶知识之基础鼠标相关函数

#### 6.5.1 主要内容

- **MOUSEMSG类型**

  首先，鼠标消息和图片一样，需要其专属的类型定义一个可以储存所需对应消息的变量，因此引入了MOUSEMSG类型

  **PS：**定义的方式和图片类型IMAGE相仿，即`MOUSEMSG 一个用于识别的字符串`

- **`MouseHit()`函数:** 它括号中没有与之相对应的参数，它的作用是用来判断是否有鼠标点击消息（通常和if语句结合使用）。

  **PS:** 通常前两个函数一般是一起使用，比如当定义完存放鼠标消息的变量以后，当使用if语句利用`MouseHit()`判断出有鼠标点击的消息以后，即可利用一个赋值语句`msg=GetMouseMsg()`将鼠标进行的行为造成的消息进行获取并存入变量msg中以便之后使用 。

- 鼠标消息结构体中的主要成员**uMsg**，可以获取鼠标消息

  主要用来判断的当前所获取消息是`WM_LBUTTONDOWN` （鼠标左键消息）还是 `WM_RBUTTONDOWN`（鼠标右键消息）
  
  此部分知识通常是用switch选择语句来判定，当左键或者右键被点击的时候会发生什么样的事件。

  当然在鼠标结构体中还有另外两个成员，分别是x和 y（即可以利用这两个成员获取当前鼠标点击位置的具体坐标）

  

#### 6.5.2 由鼠标相关函数联想到的测屏大致坐标的小技巧

可以通过printf函数，一个每次点击屏幕，然后在dos窗口上利用msg.x和msg.y来获取当前的鼠标坐标，这样可以快速测出在屏幕中所需位置的相应坐标，这样可以便于下一步对于具体位置放置相应的图片或者文字再或者是图形。

**但是对于printf函数它的显示是基于dos显示界面的，在这个时候，很有可能遇到一个小问题（但是十分致命），就是无论如何都显示不了dos窗口。**

在一开始的时候我怀疑是因为没有一个有停止作用的函数（`sleep`、`system("Pause")`、`getch()`）而导致的函数自动执行到return 0就直接将窗口关闭而导致的dos窗口无法正常显示，但是在做了这个设想的相应尝试后发现尝试无效。

最终查阅了很多的资料最终找到了我想要的答案，同时这个问题也暴露出了我对于一些细节方面的知识的学习的不全面的问题，**原因是initgraph函数中不仅仅有两个参数设置画布的长和宽，还有第三个我一直没有注意到的参数，flag（用来设定绘图窗口的样式，如是否禁用绘图窗口的关闭按钮或者是否禁用绘图窗口的最小化功能），但是最重要的功能是它可以设定是否同时显示画布和dos窗口(`EW_SHOWCONSOLE`)**。

**最终效果即相应源码如下:**

<img src="https://gitee.com/gritandsea/picture/raw/master/img/鼠标确定大致坐标.png" style="zoom:200%;" />



### 6.6 进阶知识之基础解决闪屏的函数

> 在设计程序时，为了完成动画的效果，我们需要使用清屏函数并重新绘图，此时就会产生闪屏的现象，因此需要easyx库中的函数。

- BeginBatchDraw函数，开始批量绘图
- EndBatchDraw函数，结束批量绘图

函数的内部原理是**双缓冲机制**，通常情况下，控制台显示内容的过程首先是将内容传入（打印）显示缓冲区或者在缓冲区中清除，因此为了避免这个问题，才出现了双缓冲区的概念，即当一个缓冲区显示内容的时候另一个缓冲区进行着打印或者清除的操作（此时这个缓冲区的行为没有被显示出来），之后将已经做完一系列行为的缓冲区和已经显示完准备进行下一步打印或者清除操作的缓冲区进行切换，这样即可避免闪屏的现象。

使用时，将两个函数分别放置在需要绘图的代码开头和结尾，即可解决闪屏现象（在下图中，无论我操纵小球如何移动，卡卡罗特的照片都没有闪烁）。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/解决闪屏函数.png" style="zoom:50%;" />



### 6.7 进阶知识之基础操作窗口函数

- **`GetHWnd()`函数:** 可以获取窗口句柄，利用获取到的句柄可以操作窗口。

  和前面的鼠标操作函数获取的鼠标点击消息需要被一个变量储存一样，这个窗口的句柄同样需要被一个变量储存，因此引入**`HWND`**来定义一个变量储存窗口句柄。

  **窗口句柄:** 窗口句柄可以看作是一个整数。它标识一种资源，就像你找一个人，必须知道它的地址一样，如果你要操作一种资源，必须先获得句柄。（从某种角度看，窗口句柄有些类似于指针。）

  

- **`SetWindowText()`函数:** 用来设置窗口的标题，这个函数需要传入的第一个参数是之前定义的储存窗口句柄的变量名（就类似于CSS中的类选择器使用class属性为标签命名以备之后使用这个名字有指向性的改变对应标签样式），再传入用双引号包含的将要为窗口设置的新标题（**建议无论是什么函数，只要传入的参数中有需要使用双引号包含的字符串，都先用_T()这样的宏函数将他包裹起来，这样可以利用这个函数对所包含的内容选择和环境相适应的字符处理方式来避免可能出现的问题**）。

  <img src="https://gitee.com/gritandsea/picture/raw/master/img/窗口改变.png" style="zoom:50%;" />

- **`MassageBox()`函数:** 用来控制一个弹出窗口，它可以传入很多参数，首先第一个参数有两个选择，NULL或者储存窗口句柄的变量名。

  - 如果选择NULL，那么可以随意移动弹出窗口以及画布。
  
  - 如果选择储存窗口句柄的变量名，那么就必须选择弹出窗口的选项或者关闭弹出窗口才可以移动。

  第二个参数是弹出框的内容（依然建议使用_T()将双引号包含的内容括起来），第三个参数是弹出框的标题，建议同内容输入的文字。

  第四个参数是控制弹出框的各种属性

  - 第一个输入的命令是控制弹出框中输入内容旁边的一个标识（可以显示出这个弹出框的类型）

	> X错误 MB_ICONHAND、MB_ICONSTOP、MB_ICONERROR  
	> ?询问 MB_ICONQUESTION  
	> !警告 MB_ICONEXCLAMATION 、 MB_ICONWARNING  
	> i信息 MB_ICONASTERISK 、 MB_ICONINFORMATION  
  
  - 之后使用一个`|`分隔，下一个输入的命令控制的是弹出框下方按钮的形式  
	> MB_OK 默认  
	> MB_OKCANCEL 确定取消  
	> MB_YESNO 是否  
	> MB_YESNOCANCEL 是否取消  
  - 在代码输入完以后，在最外面的大括号外用`==`输入一个控制弹出框不同按钮的返回值的命令（需要将返回值和不同的按钮相对应），通常可以通过设定一个变量来接收返回值，接着通过if语句来根据不同的按键来进行不同的行为动作。  
	> IDCANCEL 取消被选  
	> IDNO 否被选  
	> IDOK 确定被选  
	> IDYES 是被选	 
  比如在下面这个程序里，我使用了IDCANCEL ，因此如果我按下确定if语句就会返回假，进入else语句绘制一个矩形

  <img src="https://gitee.com/gritandsea/picture/raw/master/img/提示窗口.png" style="zoom:50%;" />



## 七、练习过程中的error汇总

**error LNK2005: _main already defined in easyx.obj**

由于以前学习c语言的时候统一使用的编译器是dev cpp，因此没有遇到过这样的问题，因为要使用easyx库，而这个库只支持vc系列程序，因此，只能使用vc++6.0，第一次遇到工程项目的概念

这个error出现的根源是因为在一个工程中的cpp文件中同时出现了两个main函数，而事实上一个工程中只允许一个main函数的存在，因此只要另外新建一个新项目把一个程序引入那里即可完成错误修改



**error C2665: 2 个重载中没有一个可以转换所有参数类型**

这个错误出现在loadimage函数的编译过程中，原因是由于字符集不对导致的，就目前查到的资料中，能够找到以下四种解决方法：

- 选择“项目”菜单->项目属性->配置属性->常规->字符集，改为“未设置”即可。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/字符集问题.png" style="zoom:50%;" />

- 在字符串前面加上大写的L。

  ​	在字符串前加一个L表示将ANSI字符串转换成unicode的字符串，就是每个字符占用两个字节。 

- 用一个宏函数_T（）把路径包裹起来。

  **`_T()`:** T宏可以把一个引号引起来的字符串，根据你的环境设置，使得编译器会根据编译目标环境选择合适的（Unicode还是ANSI）字符处理方式 
  	如果你定义了Unicode字符集，那么T宏会把字符串前面自动加一个L。这时 T("ABCD") 相当于 L"ABCD" ，这是宽字符串。 
  	如果没有定义，那么T宏不会在字符串前面加那个L，_T("ABCD") 就等价于 "ABCD" 

- 选择“项目”菜单->项目属性->配置属性->常规->字符集，改为“多字节字符集”同样可以。

  

**warning C4551: 缺少参数列表的函数调用**

这个问题的根源在于程序中的某个函数后面忘记加入括号了

<img src="https://gitee.com/gritandsea/picture/raw/master/img/进程冲突错误.png" style="zoom:50%;" />

这个问题的原因是因为你的easyx函数的设定背景语句在绘制画布之后，解决方法是将设定背景语句放置在画布绘制函数后面，老老实实的使用清除图形屏幕函数即可完成错误的解决（因为我一开始的设想是先对画布的颜色数据进行设定，再进行画布绘制应该可以避免使用清除图形屏幕函数，但是事实证明这个思路是错误不可行的）



## 八、题外的辅助音乐库之入门篇

> easyx库的主要使用目的多是用于游戏或者简单的动画效果这样的练手项目，为了更完善的效果，需要一定的音效辅助，因此这个库的学习对于easyx库的最终效果是有所脾益的。

首先是使用的函数需要用在开头的文件

- `#include<mmsystem.h>`
- `#pragma comment (lib,"winmm.lib")`

**PS：这个头文件之间是有着严格的顺序的，否则程序将会报错**

**以上两个头文件都需要放在`#include<graphics.h>`下面**

接下来是基础的音乐操控函数（mciSendString函数），内部参数第一个是一条命令加一个音乐播放地址

**语法示例:** `mciSendString("open 相对路径或绝对路径 alias 对这个音乐文件进行命名（相当于HTML中的id识别符）",0,0,0);`

对于参数内的open指令同样可以换为play、close分为这三个步骤进行对音乐的引用、播放以及关闭操作（这三个步骤必不可少）。

在一开始的第一个open语句中使用alias对音乐文件创建识别符后，之后的两部中的语句可以直接引用识别符代替路径。

示例如下（使用我最喜欢的紫色激情小提琴曲）：

<img src="https://gitee.com/gritandsea/picture/raw/master/img/音乐函数.png" style="zoom:50%;" />

**PS:** 在入门篇中对后面的三个参数暂时不做探究



## 九、题外的辅助键盘消息函数之入门篇

> 和上面学习的音乐库一样，作为有能力制作简单的游戏库函数的easyx库来说，键盘消息函数能够实现游戏中对于方向的控制或者是行为的控制，因此是easyx库函数必不可少的一个辅助函数。

对于辅助键盘消息函数之中的核心即能够读入键盘输入值的一个函数，在入门篇中一共会学习一下两个获取键盘消息的函数（这两个函数使用的方式和最终的效果都有着一定的差异）

- **`getch()`函数（需要头文件conio.h）:** 它的原理是获取当前的键盘信息，并将这个信息返回，其中如果输入的字符中有未被ascll码表中包含的字符，那么就需要使用虚拟键值（例如键盘中的方向键就未被ascll码表包含，因此需要用`72`、`80`、`75`、`77`分别表示上下左右），通常键盘消息函数会**和switch-case语句进行结合**，通过接收不同的键值消息来控制系统完成相应行为。

  随着对于c语言学习不断深入，逐渐的会接触到各种函数，其中有了解到getch函数有两种表示的形式（_getch()、getch()），经过在网络上的查阅了解到，使用`getch()`函数的时候最好在前面加上下划线，这样**有利于兼容性**。
  
  对于这个函数在尝试的时候一开始由于**没有使用cleardevice函数进行屏幕清除**，因此小球的移动留下了轨迹（经过分析尝试，最终明白**轨迹的颜色由这个移动的物体的最后一根线决定**，例如如果小球有外边线，那么颜色就由外边线决定，如果使用没有外边线的小球，那么就由小球的填充颜色决定）

  <img src="https://gitee.com/gritandsea/picture/raw/master/img/小球控制.png" style="zoom:50%;" />

  如果想要**消除这个轨迹，仅仅需要在重新绘制小球之前对屏幕进行清屏（cleardevice）**就可以没有轨迹出现。

- **`GetAsyncKeyState()`函数（需要头文件Windows.h）:** 它的原理和getch函数有些不同，它需要传入一个键值，然后通过当前按下的键值是否和传入的键值相符来判断将要返回的值的真假（根据此函数的特点不难看出这个函数适合**和if语句结合使用**），可以传入的键值包括`VK_UP`、`VK_DOWN`、`VK_LEFT`、`VK_RIGHT`这四个值，依次对应上下左右四个按键，由此也可以看出这个函数比较适合游戏的操作

  **PS:** 虽然键盘函数包含在Windows.h头文件里面，但是由于easyx库中包含windows头文件（通过查看graphics的文档来查看其中easyx.h头文件，再查看easyx.h文档就可以直观的看到Windows头文件被包含在其中），因此只需要引用graphics.h头文件就能够起到对Windows头文件引用的作用。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/Windows的函数头文件.png" style="zoom:50%;" />

**如果将getch函数和GetAsyncKeyState函数相比较，那么最大的不同就是它们所适合结合的语句不同，而这个特点也决定了它们在程序与运行的过程中展示出来的效果也会不同**

**首先是getch函数**，由于经常和它结合使用的是switch-case语句，因此每一轮对于按键的判断只会跳转到一个case中（也就是一次只能执行一个动作，比如在按下向上移动所对应的按键时，按下向右移动所对应的按键的时候系统将无法同时做出物体向右上方移动的操作），这样非常影响游戏的操作效果。

但是**反观GetAsyncKeyState函数**，由于使用的是if语句和它结合，因此一轮中会一次对每一个方向的按键的消息按代码顺序进行尝试获取，因此一旦同时按下两个键值，那么在这一轮系统就可以同时获取被按下的相对应的两个键值，因此可以同时做出向上和向右的操作，即可以完成斜向的行动（行动很自由）。

- **`kbhit()`函数:** 用来判断是否有键盘消息（此函数和鼠标操作中的MouseHit函数用法相同），利用if语句来判断是否有键盘消息输入，当有键盘消息输入的时候，函数返回值为真，如果没有键盘的消息传入就返回假。  

---  

## 参考资料

- [封装](https://baike.baidu.com/item/%E5%B0%81%E8%A3%85/2796965?fr=aladdin)

- [宿主程序](https://baike.baidu.com/item/宿主程序)

- [lib文件](https://baike.baidu.com/item/lib文件/2108657?fr=aladdin)

- [bin文件夹和lib文件夹](https://blog.csdn.net/beifangdefengchuilai/article/details/88769024)

- [easyx帮助文档](https://docs.easyx.cn/zh-cn/setup)

- [静态数据](https://baike.baidu.com/item/静态数据/10528956)

- [Windows API](https://baike.baidu.com/item/Windows%20API/6088382?fr=aladdin)

- [学会调色，从理解HSL面板开始](https://m.sohu.com/sa/223400109_768280)

- [_getch() 和 getch() 及 _T（）](https://www.cnblogs.com/lvdongjie/p/4500506.html)

- [c++字符前面的L和_T](https://www.cnblogs.com/wliangde/p/4073659.html)

- [easyx有什么函数可以显示出](https://tieba.baidu.com/p/5175950366?red_tag=3194982187)

- [C语言游戏开发闪屏解决办法--双缓冲技术](https://blog.csdn.net/NEFU_kadia/article/details/106211471)

- [窗口与句柄](https://blog.csdn.net/hk121/article/details/83537182)

- [MessageBox](https://baike.baidu.com/item/MessageBox/3846797?fr=aladdin)









