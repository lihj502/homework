# 来自学长的灵魂拷问之c语言题目学习笔记

   * [来自学长的灵魂拷问之c语言题目学习笔记](#来自学长的灵魂拷问之c语言题目学习笔记)
      * [一、问题回顾](#一问题回顾)
      * [二、程序内部运行过程简述](#二程序内部运行过程简述)
      * [三、变化过程细节的查看](#三变化过程细节的查看)
      * [四、注释之理解字节序](#四注释之理解字节序)
      * [五、注释之”\xp”的意思](#五注释之p的意思)
      * [六、注释之指针的强制类型转换](#六注释之指针的强制类型转换)
      * [七、查看十六进制的方法](#七查看十六进制的方法)
      * [八、注释之为什么采用十六进制的视角看待这个问题](#八注释之为什么采用十六进制的视角看待这个问题)
      * [九、为什么被强制转化为char型的地址进行移动后，指向的十六进制数值发生了两位的移动？](#九为什么被强制转化为char型的地址进行移动后指向的十六进制数值发生了两位的移动)


## 一、问题回顾

**下图中数组究竟为何会发生变化？**

<img src="https://gitee.com/gritandsea/picture/raw/master/img/问题回顾.jpg" style="zoom: 80%;" />





## 二、程序内部运行过程简述

对于此问题，主要矛盾在于无法理解c = (int *)((char *) c + 1);这句话究竟做了什么,映射到计算机内部，会发生什么样的变化。  

因此对于前面的语句仅仅简单梳理，主要对c = (int *)((char *) c + 1);之后的变化进行逐步的解释。

1. 定义一个**int类型指针**指向定义的数组首地址

2. 将指针移动**int类型的长度**（四个字节），此时指向a[1]

3. 执行c = (int *)((char *) c + 1);语句以及之后的语句

   - 首先，c的指针类型被**强制转化**（下文中简称为强转，之后有对于这个内容的详细说明）为char型的指针（对应的是(char *) c语句），因此对这个指针再次+1的时候，指针的移动位置就由原来的int型的移动（+1移动四个字节），变为**char型的移动**（+1移动一个字节）。

   - 因此此时指针指向的地址+1。

   - 这个对应的是指针移动到地址中存放的十六进制数值的下两位数（由于在**计算机中采用小端字节序**，因此数值的十六进制表示会将它的顺序进行一个调换）

     <img src="https://gitee.com/gritandsea/picture/raw/master/img/指针位置变化.jpg" style="zoom:25%;" />

     **PS:** 借用学长的思路再做细节说明

   - 又由于地址和十六进制的数值有着某种关系，因此似乎指针对地址进行加减时，指针指向对应的十六进制数值也发生了同样的变化。

     **但是为什么呢？**

     详见之后内容的“对于十六进制和地址之间的联系的猜测”

- 之后又再次采用**int类型的指针强转**（(int *)((char *) c + 1)），将指向的十六进制数值变回为8位数，同时对应着地址的8位。
- 由于在计算机中是采用的小端字节序。
- 同时**在数组中，数据的储存是一片连续的区域**。
- 因此在之后将要赋值的500，就在目前指针所指的位置选择了对应大小的区域（从指针所指的位置向后数8位），对这一片区域（横跨a[1]和a[2]）进行了赋值
- 但是在数组中依然按照正常的区域进行划分对十六进制数值进行十进制的转化和读取（如果使用%x或者%p就可以清除的看到这个过程的变化）。
- 因此这个赋值的操作完全打乱了数组第二位和第三位的数值。
- 最终使用十进制（%d）打印数组时才会发生这样的变化

**PS：整体流程如下图（引用学长的解释）**

<img src="https://gitee.com/gritandsea/picture/raw/master/img/4e01c312d4f9038c50fcd39ed361518.jpg" style="zoom: 25%;" />



## 三、变化过程细节的查看

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210104111517.png" style="zoom: 50%;" />

我在指针c移动并进行了两次强转并移动了一个char型大小的c所指向的地址中存放的数值进行查看。

此时的c地址中的数值十进制表示为1577038304，当换算为十六进制时表示为5E000000

对这个十六进制数值按计算机内部的小端字节序表示，和上图学长所画移动后框选的范围数值相同

<img src="https://gitee.com/gritandsea/picture/raw/master/img/错误更改.jpg" style="zoom: 25%;" />

之后输出的a[1]=]128250换算为十六进制也是1F4FA

a[2]=256同样也是对应着十六进制的100

而有了这样的一个过程的概念，就可以理解c = (int *)((char *) c + 4)为什么就是对a[2]正常赋值了

因为char型的指针移动了四个字节指向了5e的位置，再转换为int型，就指向了a[2]所处的所有十六进制数值



## 四、注释之理解字节序

**计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）**。

举例来说，数值`0x2211`使用两个字节储存：高位字节是`0x22`，低位字节是`0x11`。

- 大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。
- 小端字节序：低位字节在前，高位字节在后，即以`0x1122`形式储存。

**首先，为什么会有小端字节序？**

答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。

但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。

​																						引用自——[理解字节序 大端字节序和小端字节序](https://www.cnblogs.com/gremount/p/8830707.html)



## 五、注释之”%p”的意思

<img src="https://img-blog.csdn.net/20180510002607984" style="zoom: 50%;" />

​																											引用自——[C语言”%p”的意思](https://blog.csdn.net/i_pangpang/article/details/80261647)



## 六、注释之指针的强制类型转换

`格式：（类型说明符 *）指针表达式` 

不管是什么类型的指针变量，所存的值都是相同的地址。

**那么声明不同类型的作用是什么？**

答案是规定指针在内存中每次移动的字节数。

​																											引用自——[指针强制类型转换的理解](https://www.cnblogs.com/al-fajr/p/11615413.html)



## 七、查看十六进制的方法

**变量数值的十六进制和它对应的地址之间的关系**

<img src="https://gitee.com/gritandsea/picture/raw/master/img/十六进制.png" style="zoom:67%;" />

**这里提出一个符号`%p`，它可以按照十六进制的格式输出数据，如果不够8位数，将会在左边补零。**

在对应地址进行+1的时候，地址存放对应的十六进制数值也相应的发生了变化，即指针移动对应类型长度，指向下一个数值。

**对于为什么一直在说八位而不是四个字节的解释**

一个char可以最多存两位数（这就是一个字节等于两位），再多出一位程序就会出现数据溢出，输出错误的数值

<img src="https://gitee.com/gritandsea/picture/raw/master/img/数据没溢出.png" style="zoom: 67%;" />

<img src="https://gitee.com/gritandsea/picture/raw/master/img/数据溢出.png" style="zoom: 67%;" />



## 八、注释之为什么采用十六进制的视角看待这个问题

在计算机内部，数据的储存是由二进制储存的，但是二进制并不适合人类阅读，因此需要采用其他的视角来看待这个问题。

**首先一个十六进制的数字可以直接由四个二进制数字来表示**，因此十六进制和二进制之间有着一定的相关性

由此可以看出，十六进制的表示会强于十进制的表示。

**明白了上面的这个问题以后就更容易理解“为何黄尚科学长的示意图是那样的表示？”这个问题了。**

一个字节可以存放八个二进制数字，因此一个字节就对应着两个十六进制数字，所以示意图才会用那种方式进行表示。



## 九、为什么被强制转化为char型的地址进行移动后，指向的十六进制数值发生了两位的移动？

假设我的指针指向了a[0]

在一个int型的数组中，储存的数值地址是一片连续的区域，因此，每一字节都对应着一个地址，而这些地址与地址之间相差一个字节，又因为一个int型包含四个字节，所以一个a[0]就包含了四个连续的地址，只不过指针指向的是a[0]的首地址
所以当我将指针强转为char型后，地址进行加一，就是到了下一个地址，也就是下一个字节（这个字节包含了八个二进制数，也就是两位十六进制数）。
如果假设我没有对指针进行强转，那么int型的指针地址进行加一，就是连续移动了四个地址，也就是到了第五个字节（a[1]）。

<img src="https://gitee.com/gritandsea/picture/raw/master/img/20210104115013.png" style="zoom:50%;" />





